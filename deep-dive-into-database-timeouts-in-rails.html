<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Deep Dive into Database Timeouts in Rails</title>
    <meta name="description" content="Disaster strikes when you do not configure timeout values properly. In this post, we dive into the details of how timeouts work with Ruby on Rails and Databases.">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <!-- Open Graph -->
    <meta property="og:url" content="https://engineering.grab.com/deep-dive-into-database-timeouts-in-rails">
    <meta property="og:title" content="Deep Dive into Database Timeouts in Rails">
    <meta property="og:description" content="Disaster strikes when you do not configure timeout values properly. In this post, we dive into the details of how timeouts work with Ruby on Rails and Databases.">
    <meta property="og:site_name" content="Grab Tech">
    <meta property="og:type" content="article">
    <meta property="og:image" content="https://engineering.grab.com/img/banner.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Favicons -->
    <link rel="icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">

    <!-- CSS -->
    <link href="//fonts.googleapis.com/css?family=Droid+Serif:400,400i,700,700i" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap-theme.min.css">
    <script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://engineering.grab.com/deep-dive-into-database-timeouts-in-rails">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="RSS for Official Grab Tech Blog" href="/feed.xml">
</head>

  <body>
    <header class="site-header">
  <div class="wrapper">
    <div class="site-title-wrapper">
      <div class="row site-title-wrapper-inner">
        <div class="col-sm-8 col-xs-4">
          <div>
            <a class="site-title" href="/"></a>
            <span class="site-subtitle hidden-xs">&nbsp;Tech Blog</span>
          </div>
        </div>
        <div class="col-sm-4 col-xs-8 text-right site-search">
          <form action="/search.html" method="get">
  <div class="input-group">
    <input type="text" id="search" name="q" class="form-control" placeholder="Search...">
    <span class="input-group-btn">
      <button class="btn" type="submit"><i class="fa fa-search"></i></button>
    </span>
  </div>
</form>

        </div>
      </div>
    </div>
    <nav>
      <ul class="nav-category">
        
          
          <li>
            <a href="/categories/engineering/">Engineering</a>
          </li>
        
          
          <li>
            <a href="/categories/data-science/">Data Science</a>
          </li>
        
          
          <li>
            <a href="/categories/design/">Design</a>
          </li>
        
          
          <li>
            <a href="/categories/product/">Product</a>
          </li>
        
      </ul>
    </nav>
  </div>
</header>

    <div class="page-content">
      
<div class="wrapper">
  <div class="post">
    <header class="post-header">
      <div class="text-center">
        
          
            
            
              <img class="post-author-thumbnail-large img-circle" src="/img/authors/jia-hao-goh.jpg">
            
          
        
      </div>
      <br>
      <h1 class="post-title text-center">Deep Dive into Database Timeouts in Rails</h1>
      <div class="post-meta">
        29 Jan 2018
        
          
            
            
              &middot;
              
                Jia Hao Goh
              
            
          
        
        
        
          <div class="post-tags">
  
  
    <a href="/tags#back-end" class="label tags-label">Back End</a>
  
    <a href="/tags#database" class="label tags-label">Database</a>
  
    <a href="/tags#distributed-systems" class="label tags-label">Distributed Systems</a>
  
    <a href="/tags#ruby" class="label tags-label">Ruby</a>
  
    <a href="/tags#ruby-on-rails" class="label tags-label">Ruby on Rails</a>
  
</div>

        
      </div>
    </header>
    <article class="post-content">
      <p>A couple of weeks ago, we had a production outage for one of our internal Ruby on Rails application servers. One of the databases that the application connects to had a failover event. It was expected that the server should continue functioning for endpoints which do not depend on this database, but it was observed that our server slowed down to a crawl, and was unable to function properly even after the failover completed, until we manually restarted the servers.</p>

<h2 id="background">Background</h2>

<p><a href="http://guides.rubyonrails.org/active_record_basics.html">ActiveRecord</a> is the canonical ORM for Rails to access a database. Different requests are handled on different threads, so a connection pool is necessary to maintain a limited set of connections to the database and also to skip the additional latency of establishing a TCP connection.</p>

<blockquote>
  <p>A connection pool synchronizes thread access to a limited number of database connections. The basic idea is that each thread checks out a database connection from the pool, uses that connection, and checks the connection back in.</p>
</blockquote>

<blockquote>
  <p>It will also handle cases in which there are more threads than connections: if all connections have been checked out, and a thread tries to checkout a connection anyway, then ConnectionPool will wait until some other thread has checked in a connection.</p>
</blockquote>

<p>Source: The <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html"><code class="highlighter-rouge">ActiveRecord::Connection Pool</code></a> .</p>

<h3 id="options-for-the-connection-pool">Options for the Connection Pool</h3>

<p>In Rails, database configurations are set in the <code class="highlighter-rouge">config/database.yml</code> file. These options are either native to the <code class="highlighter-rouge">ActiveRecord::ConnectionPool</code> module, or passed to the underlying adapter, depending on whether MySQL or PostgreSQL is used.</p>

<p>ActiveRecord uses connection adapters to make database calls. For MySQL, it uses the <a href="https://github.com/brianmario/mysql2">mysql2</a> library, which depends on the <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-implementations.html"><code class="highlighter-rouge">libmysqlclient</code></a> C library. The following options affect the behaviour of the library:</p>

<table class="table table-bordered">
  <thead>
    <tr>
      <th>Option</th>
      <th>Description</th>
      <th>Source</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">pool</code></td>
      <td>This specifies the maximum number of connections to the database that ActiveRecord will maintain per server.</td>
      <td>Native to the <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html">ActiveRecord ConnectionPool</a></td>
      <td>5 <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html#class-ActiveRecord::ConnectionAdapters::ConnectionPool-label-Options">Source</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">checkout_timeout</code></td>
      <td>When making a ActiveRecord call, ActiveRecord tries to checkout a database connection from the pool. If the pool is at maximum capacity, ActiveRecord will wait for this timeout to elapse before raising an <code class="highlighter-rouge">ActiveRecord</code> <code class="highlighter-rouge">ConnectionTimeoutError</code> exception.</td>
      <td>Native to the <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html">ActiveRecord ConnectionPool</a></td>
      <td>5 seconds <a href="https://github.com/rails/rails/blob/e5dc756bf9424086c403d1025971c3e704e1dcfa/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L328">Source</a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">connect_timeout</code></td>
      <td>If there are no available connections to the database in the connection pool, a new connection will have to be established. <code class="highlighter-rouge">connect_timeout</code>, specifies the timeout to establish a new connection to the database before failing.</td>
      <td>Native to the <a href="https://github.com/brianmario/mysql2">mysql2</a> library, passed to <code class="highlighter-rouge">libmysqlclient</code> as <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-options.html"><code class="highlighter-rouge">MYSQL_OPT_CONNECT_TIMEOUT</code></a></td>
      <td>120 seconds <a href="https://github.com/brianmario/mysql2/blob/a1c198ee4c8d4d32dfa79f207ec7d0524c5f7bcc/lib/mysql2/client.rb#L31">Source</a>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">read_timeout</code></td>
      <td>Read timeout is used by the <code class="highlighter-rouge">libmysqlclient</code> library to identify whether the MySQL client is still alive and sending data. As we know that TCP sends data in chunks, the client waits for this timeout when reading from the socket, before deeming that there is an error and closing the connection.</td>
      <td>Native to the <a href="https://github.com/brianmario/mysql2">mysql2</a> library, passed to <code class="highlighter-rouge">libmysqlclient</code> as <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-options.html"><code class="highlighter-rouge">MYSQL_OPT_READ_TIMEOUT</code></a></td>
      <td>3 × 10 minutes <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-options.html">Source</a></td>
    </tr>
  </tbody>
</table>

<h3 id="connection-pooling-algorithm">Connection Pooling Algorithm</h3>

<p>The following pseudocode is the algorithm for how ActiveRecord retrieves connections from the pool to perform database queries.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">existing</span> <span class="n">connections</span> <span class="n">to</span> <span class="n">the</span> <span class="n">database</span> <span class="n">available</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">existing</span> <span class="n">connections</span>

<span class="k">if</span> <span class="n">the</span> <span class="n">pool</span> <span class="ow">is</span> <span class="n">at</span> <span class="n">capacity</span><span class="p">:</span>
    <span class="n">wait</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span><span class="p">,</span> <span class="k">raise</span> <span class="n">exception</span> <span class="k">if</span> <span class="sb">`checkout_timeout`</span> <span class="n">has</span> <span class="n">elapsed</span>
    <span class="k">return</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">now</span> <span class="n">available</span> <span class="n">connections</span>

<span class="c"># pool is not at capacity</span>
<span class="k">try</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">connection</span><span class="p">,</span> <span class="k">raise</span> <span class="n">exception</span> <span class="k">if</span> <span class="sb">`connect_timeout`</span> <span class="n">has</span> <span class="n">elapsed</span>

<span class="c"># connection to database established</span>
<span class="k">return</span> <span class="n">new</span> <span class="n">connection</span>
</code></pre>
</div>

<p>This is loosely translated from the <a href="https://github.com/rails/rails/blob/5.1.3/activerecord/lib/active_record/connection_adapters/abstract/connection_pool.rb#L725-L749">source code</a>.</p>

<h2 id="replicating-and-debugging">Replicating and Debugging</h2>

<p>Let’s try to replicate the problem in a small Rails application. We will create a new Rails application, connect it to a database, run it in a Docker container and finally run some experiments to replicate the problem. In production, we use <a href="https://github.com/puma/puma">Puma</a> to run our Rails server and connect to a few MySQL databases managed by <a href="https://aws.amazon.com/rds/">Amazon Relational Database Service (RDS)</a>, so we will try to follow that on our local setup.</p>

<h3 id="step-1-create-a-new-rails-application">Step 1: Create a new Rails Application</h3>

<p>First, we will scaffold a fresh Rails application and connect it to two databases that we will call as <code class="highlighter-rouge">db_main</code> and <code class="highlighter-rouge">db_other</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c"># the flags removes unwanted boilerplate code</span>
rails new rails-mysql-timeouts --database<span class="o">=</span>mysql --api -M -C -S -J -T
</code></pre>
</div>

<p>For simplicity, we will set the <code class="highlighter-rouge">thread_count</code> of our Puma server to <code class="highlighter-rouge">2</code>, in <code class="highlighter-rouge">config/puma.rb</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">threads_count</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre>
</div>

<p>Using <code class="highlighter-rouge">rails generate scaffold</code>, we set up a <code class="highlighter-rouge">Driver</code> model to talk to our main database, and a <code class="highlighter-rouge">Passenger</code> model to talk to another database we want to test the failure on. This can be done by adding the following line to our <code class="highlighter-rouge">Passengers</code> model.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Passenger</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="c1"># connect to #{Rails.env}_other database specified in the database.yml</span>
  <span class="n">establish_connection</span> <span class="s2">"</span><span class="si">#{</span><span class="no">Rails</span><span class="p">.</span><span class="nf">env</span><span class="si">}</span><span class="s2">_other"</span><span class="p">.</span><span class="nf">to_sym</span>
<span class="k">end</span>
</code></pre>
</div>

<p>We now have the following HTTP routes:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># connects to db_main
GET /drivers/1

# connects to db_other
GET /passengers/1
</code></pre>
</div>

<p>Now we will run our Rails server with the following environment variables</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nb">export </span><span class="nv">RAILS_ENV</span><span class="o">=</span>production
<span class="nb">export </span><span class="nv">RAILS_LOG_TO_STDOUT</span><span class="o">=</span>1

rails server
</code></pre>
</div>

<p>By using a docker container to run the Rails application, we can isolate the process namespace and focus directly on our application. We run <code class="highlighter-rouge">ps</code> and observe the two threads we have configured puma — <code class="highlighter-rouge">puma 001</code> and <code class="highlighter-rouge">puma 002</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>ps -T -e
  PID  SPID TTY          TIME CMD
    1     1 ?        00:00:00 sleep
   30    30 pts/1    00:00:00 bash
   63    63 pts/0    00:00:00 bash
   97    97 pts/1    00:00:03 ruby
   97    99 pts/1    00:00:00 ruby-timer-thr
   97   105 pts/1    00:00:00 tmp_restart.rb<span class="k">*</span>
   97   106 pts/1    00:00:00 puma 001
   97   107 pts/1    00:00:00 puma 002
   97   108 pts/1    00:00:00 reactor.rb:152
   97   109 pts/1    00:00:00 thread_pool.rb<span class="k">*</span>
   97   110 pts/1    00:00:00 thread_pool.rb<span class="k">*</span>
   97   111 pts/1    00:00:00 server.rb:327
  112   112 pts/0    00:00:00 ps
</code></pre>
</div>

<p>Note that PID 1 is <code class="highlighter-rouge">sleep</code> because in <a href="https://github.com/grab/blogs/tree/master/2017-01-29-deep-dive-into-database-timeouts-in-rails/docker-compose.yml"><code class="highlighter-rouge">docker-compose.yml</code></a>, we specified that the container should start with <code class="highlighter-rouge">cmd: sleep infinity</code> so that we can attach to the running container at any time, not unlike a <code class="highlighter-rouge">ssh</code> to a machine.</p>

<h3 id="step-2-verify-our-application">Step 2: Verify Our Application</h3>

<p>We make the following requests to ensure that our server is working correctly:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl localhost:3000/drivers
<span class="o">[{</span><span class="s2">"id"</span>:1,<span class="s2">"name"</span>:<span class="s2">"test driver"</span>,<span class="s2">"created_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span>,<span class="s2">"updated_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span><span class="o">}]</span>

<span class="gp">$ </span>curl localhost:3000/passengers
<span class="o">[{</span><span class="s2">"id"</span>:1,<span class="s2">"name"</span>:<span class="s2">"test"</span>,<span class="s2">"created_at"</span>:<span class="s2">"2017-01-01T00:00:00.000Z"</span>,<span class="s2">"updated_at"</span>:<span class="s2">"2017-01-07T00:00:00.000Z"</span><span class="o">}]</span>
</code></pre>
</div>

<p>Great! We are now able to see the records generated in the database by the above curl requests.</p>

<p>The entire source code for this application can be found <a href="https://github.com/grab/blogs/tree/master/2017-01-29-deep-dive-into-database-timeouts-in-rails">here</a>.</p>

<h3 id="step-3-simulating-the-production-issue">Step 3: Simulating the Production Issue</h3>

<p>We will now try to simulate the production issue by using a proxy to monitor all our TCP connections from our Rails application to our database. Finally, we will run some experiments by sending requests that hit the backend database and analyse the behaviour of both <code class="highlighter-rouge">connect_timeout</code> and <code class="highlighter-rouge">read_timeout</code> settings.</p>

<p>First, we use <a href="https://github.com/Shopify/toxiproxy">Toxiproxy</a> as a transport layer proxy to <code class="highlighter-rouge">db_other</code> which allows us to manipulate the pipe between the client and the upstream database. The following command stops all data from getting the proxy, and closes the connection after timeout.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>toxiproxy-cli toxic add db_other_proxy --toxicName timeout --type timeout --attribute<span class="o">=</span><span class="nv">timeout</span><span class="o">=</span>100000
</code></pre>
</div>

<p>Now we test if things are still working for endpoints that access the unaffected database.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl localhost:3000/drivers
<span class="o">[{</span><span class="s2">"id"</span>:1,<span class="s2">"name"</span>:<span class="s2">"test driver"</span>,<span class="s2">"created_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span>,<span class="s2">"updated_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span><span class="o">}]</span>
</code></pre>
</div>

<p>This is expected, as the <code class="highlighter-rouge">db_main</code> is still running. Let’s trigger a request to <code class="highlighter-rouge">db_other</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl localhost:3000/passengers
</code></pre>
</div>

<p>We notice that the command does not exit and our terminal blocks while waiting for the command to terminate.</p>

<p>Let’s trigger another call to <code class="highlighter-rouge">db_main</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl localhost:3000/drivers
<span class="o">[{</span><span class="s2">"id"</span>:1,<span class="s2">"name"</span>:<span class="s2">"test driver"</span>,<span class="s2">"created_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span>,<span class="s2">"updated_at"</span>:<span class="s2">"2017-11-05T11:59:15.000Z"</span><span class="o">}]</span>
</code></pre>
</div>

<p>Seems like it still works! Now let’s make another request to the <code class="highlighter-rouge">db_other</code> to lock up the two threads our server is configured to use.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl localhost:3000/passengers
</code></pre>
</div>

<p>And make another request to <code class="highlighter-rouge">db_main</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>curl localhost:3000/drivers
</code></pre>
</div>

<p>Notice that the call to <code class="highlighter-rouge">/drivers</code> is stuck and does not complete now. Because we have set the thread count to <code class="highlighter-rouge">2</code>, and have two <code class="highlighter-rouge">/passengers</code> requests in flight, both threads are stuck waiting for the database and we do not have any more threads available to handle the new request, hence the stalled <code class="highlighter-rouge">/drivers</code> request.</p>

<p>This is exactly what happened during our production outage, except on a much larger scale.</p>

<h3 id="experiments">Experiments</h3>

<p>Let’s perform some experiments to better understand how <code class="highlighter-rouge">connect_timeout</code> and <code class="highlighter-rouge">read_timeout</code> work. We will set the timeouts to the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="s">+ connect_timeout</span><span class="pi">:</span> <span class="s">10</span>
<span class="s">+ read_timeout</span><span class="pi">:</span> <span class="s">5</span>
</code></pre>
</div>

<p>In the following section we will perform two experiments.</p>

<h4 id="experiment-1-application-has-no-existing-connections-before-database-failure">Experiment 1: Application has no Existing Connections before Database Failure</h4>

<ol>
  <li>Stop data transmission to <code class="highlighter-rouge">db_other</code></li>
  <li>Start Rails</li>
  <li><code class="highlighter-rouge">GET /passengers</code></li>
</ol>

<p>We first block data to <code class="highlighter-rouge">db_other</code> , so that on the first ActiveRecord call to retrieve some data from the database, there are no available connections in the connection pool and it needs to establish a fresh connection to the database when it receives the first <code class="highlighter-rouge">GET /passengers</code> request.</p>

<h4 id="experiment-2-application-has-existing-connections-before-database-failure">Experiment 2: Application has Existing Connections before Database Failure</h4>

<ol>
  <li>Start Rails</li>
  <li><code class="highlighter-rouge">GET /passengers</code></li>
  <li>Stop data transmission to <code class="highlighter-rouge">db_other</code></li>
  <li><code class="highlighter-rouge">GET /passengers</code></li>
</ol>

<p>We’ve started Rails and make a call to <code class="highlighter-rouge">GET /passengers</code>. A connection to the database is established to retrieve the data, and checked back into the pool as an available connection after the request.</p>

<p>Now, when the proxy stops sending data to <code class="highlighter-rouge">db_other</code>, ActiveRecord does not know that the database is unavailable and believes that the previously checked in connection is available for use with the second <code class="highlighter-rouge">GET /passengers</code>.</p>

<p>We can use the <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code class="highlighter-rouge">ss</code></a> command to observe the TCP connections. When Rails has just been started, there are no existing TCP connections .</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c"># shows TCP connections with the PID</span>
<span class="gp">$ </span>ss -tnp
</code></pre>
</div>

<p>After a <code class="highlighter-rouge">GET /passengers</code> completes, a TCP connection can be seen in the <code class="highlighter-rouge">ESTAB</code> state.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>ss -tnp
State      Recv-Q Send-Q       Local Address:Port         Peer Address:Port
ESTAB      0      0               172.18.0.4:54304          172.18.0.3:3306   users:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>13<span class="o">))</span>
</code></pre>
</div>

<p>Now we stop the database, and make another call to <code class="highlighter-rouge">GET /passengers</code>. We run <code class="highlighter-rouge">ss</code> when the request is in flight, and observe another TCP connection for the request to the port Rails listens on, port <code class="highlighter-rouge">3000</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>ss -tnp
State      Recv-Q Send-Q       Local Address:Port         Peer Address:Port
ESTAB      0      0               172.18.0.4:54304          172.18.0.3:3306   users:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>13<span class="o">))</span>
ESTAB      0      0               172.18.0.4:3000           172.18.0.1:60878  users:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>12<span class="o">))</span>
</code></pre>
</div>

<p>After <code class="highlighter-rouge">read_timeout</code> has elapsed, we see that a new connection is established to the database, and the first one has transitioned to a <code class="highlighter-rouge">FIN-WAIT</code> state. This new TCP connection is in the <code class="highlighter-rouge">ESTAB</code> state (line 3), because we have only stopped the database on the application layer, but the sockets to the container still accept the TCP handshake on the transport layer.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>ss -tnp
FIN-WAIT-2 0      0               172.18.0.4:54304          172.18.0.3:3306
ESTAB      0      0               172.18.0.4:54308          172.18.0.3:3306   users:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>13<span class="o">))</span>
ESTAB      0      0               172.18.0.4:3000           172.18.0.1:60878  users:<span class="o">((</span><span class="s2">"ruby"</span>,pid<span class="o">=</span>11683,fd<span class="o">=</span>12<span class="o">))</span>
</code></pre>
</div>

<p>After <code class="highlighter-rouge">connect_timeout</code> has elapsed, the request terminates with a 500 error, and we observe that all the connections are in the <code class="highlighter-rouge">FIN-WAIT</code> state.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>ss -tnp
State      Recv-Q Send-Q       Local Address:Port         Peer Address:Port
FIN-WAIT-2 0      0               172.18.0.4:54310          172.18.0.3:3306
FIN-WAIT-2 0      0               172.18.0.4:54304          172.18.0.3:3306
FIN-WAIT-2 0      0               172.18.0.4:54308          172.18.0.3:3306
</code></pre>
</div>

<p>The experimental data can be found <a href="#experimental-data">below</a>.</p>

<h4 id="findings">Findings</h4>

<p>It’s worth noting that when setting <code class="highlighter-rouge">connect_timeout</code> and <code class="highlighter-rouge">read_timeout</code> in the <code class="highlighter-rouge">database.yml</code>, there is a difference between empty values and the case where the key is missing entirely in the file. If the values are empty, scenario 1 will fail to terminate after 5 minutes, but if the keys are absent, scenario 1 will fail after 120 seconds, which is the default for <code class="highlighter-rouge">connect_timeout</code>.</p>

<h5 id="experiment-1-findings">Experiment 1 Findings</h5>

<p>The request waits for <code class="highlighter-rouge">connect_timeout</code> to connect to the database, where the default value (when not specified) is indeed 120 seconds.</p>

<p>As expected, connecting to the database with no existing connections is independent of the <code class="highlighter-rouge">read_timeout</code>.</p>

<h5 id="experiment-2-findings">Experiment 2 Findings</h5>

<p>The request waits for <code class="highlighter-rouge">read_timeout</code> + <code class="highlighter-rouge">connect_timeout</code> before failing. This is because the connection pool waits for <code class="highlighter-rouge">read_timeout</code> on the existing connection before terminating it, and then waits for <code class="highlighter-rouge">connect_timeout</code> as it tries to establish a new connection to <code class="highlighter-rouge">db_other</code>.</p>

<h2 id="analysis">Analysis</h2>

<p>With these findings, we can try to understand how the lack of these timeouts affected our Rails server in production during and after the database failover.</p>

<h3 id="establishing-terms">Establishing Terms</h3>

<p>Our application server constantly receives requests, out of which a certain percentage of requests will trigger the code to connect to the affected database, which we’ll call <em>x</em>-type requests. The other requests, that do not trigger a database connection, we’ll call <em>x’</em>-type requests.</p>

<h3 id="analysis-1">Analysis</h3>

<p>With the background knowledge gathered in our experiments, let’s try to analyse all the steps that happened during our production outage.</p>

<ol>
  <li>Rails started from a clean state, with no connections set up to the database initially</li>
  <li>Rails handles the first few <em>x</em> request types, opens a connection to the database</li>
  <li>Subsequent requests of <em>x</em> type can reuse the same connections from the connection pool</li>
  <li>At a certain time, due to a hardware fault out of our control, a failover of the database is triggered</li>
  <li>At the same time requests of <em>x</em> type comes in — and ActiveRecord reuses the same database connection from the pool, but there is no response. It then waits for <code class="highlighter-rouge">read_timeout</code>, causing the thread to be stuck waiting for the default timeout</li>
  <li>Even though Rails can process requests of the <em>x’</em> type normally, more and more requests of <em>x</em> type come in and cause more and more threads to be stuck waiting</li>
  <li>Eventually, all the available threads to handle requests are stuck waiting on the TCP connection to the failed database, and Rails can no longer respond to new requests</li>
  <li>After the default <code class="highlighter-rouge">read_timeout</code> has elapsed (3 × 10 minutes), some threads will be released to handle new requests</li>
  <li>Subsequent requests of <em>x</em> type will cause a new connection to be opened to the database
    <ul>
      <li>If the failover is complete and the DNS records for the new instance has been updated, the new connections will be established</li>
      <li>If the failover is not complete or the DNS records were not updated, the TCP connections will still try to connect to the old IP address with the failed database instance. The connections will wait for the <code class="highlighter-rouge">connect_timeout</code> (default 120 seconds) to elapse before failing</li>
    </ul>
  </li>
  <li>Finally, once all the threads are stuck, our Rails application stops responding to all requests until it was restarted manually</li>
</ol>

<h4 id="solution">Solution</h4>

<p>To fix the problem, we have to prevent our database connections from being stuck in trying to read from an unresponsive socket, and trying to connect to a closed socket.</p>

<p>This can be done by simply setting the <code class="highlighter-rouge">read_timeout</code> so that when the database fails, existing connections and threads will be released. The <code class="highlighter-rouge">connect_timeout</code> also has to be set so that when the existing connections are released, new connections and threads handling the requests will not be stuck trying to connect to the same unavailable database.</p>

<p>We set the following values in our staging environment and manually triggered a database failover via the AWS console, and observed that requests of the <em>x’</em> type are no longer stalled during the failover.</p>

<p>The following is a snippet for our current <code class="highlighter-rouge">database.yml</code> configuration before the outage, and the changes to resolve the problem.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1"># Config for the non-primary `db_other` database</span>
<span class="s">production_other</span><span class="pi">:</span>
  <span class="s">adapter</span><span class="pi">:</span> <span class="s">mysql2</span>
  <span class="s">encoding</span><span class="pi">:</span> <span class="s">utf8</span>
  <span class="s">reconnect</span><span class="pi">:</span> <span class="s">false</span>
  <span class="s">database</span><span class="pi">:</span> <span class="s">…</span>
  <span class="s">pool</span><span class="pi">:</span> <span class="s">…</span>
  <span class="s">reaping_frequency</span><span class="pi">:</span> <span class="s">120</span>
  <span class="s">username</span><span class="pi">:</span> <span class="s">…</span>
  <span class="s">password</span><span class="pi">:</span> <span class="s">…</span>
  <span class="s">host</span><span class="pi">:</span> <span class="s">…</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1"># New changes</span>
<span class="s">+ connect_timeout</span><span class="pi">:</span> <span class="s">5</span>
<span class="s">+ read_timeout</span><span class="pi">:</span> <span class="s">5</span>
</code></pre>
</div>

<h2 id="conclusion">Conclusion</h2>

<p>In this post, we have gone over how timeouts are handled by the ActiveRecord ORM with our MySQL database and how failing to configure them brought down some of our production systems.</p>

<p>Timeouts are very important configurations when setting up distributed systems and they are easily overlooked in the initial deployments of such applications.</p>

<p>These principles are not just limited to Rails or MySQL, and the experiments and their findings can be easily extended to other technologies as well. Needless to say, these timeout settings are extremely important for the resiliency of applications in the world of micro services.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts">ankane/the-ultimate-guide-to-ruby-timeouts</a></li>
  <li><a href="https://github.com/ankane/production_rails">ankane/production_rails</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-options.html">MySQL Reference Manual</a></li>
  <li><a href="https://github.com/zach14c/mysql/blob/mysql-5.7/include/mysql_com.h#L298">MySQL Source Code Mirror</a></li>
  <li><a href="https://blog.confirm.ch/tcp-connection-states/">TCP Connection States</a></li>
</ul>

<p>Big thanks to <a href="https://github.com/lowjoel">Joel Low</a> for helping out with this investigation and clarifying ambiguities in Rails and MySQL, and my manager Amit Saini for his helpful review of this post!</p>

<p>Source code for the test rails application can be found <a href="https://github.com/grab/blogs/tree/master/2017-01-29-deep-dive-into-database-timeouts-in-rails">here</a>.</p>

    </article>
    <div>
      
        <div class="post-tags">
  
  
    <a href="/tags#back-end" class="label tags-label">Back End</a>
  
    <a href="/tags#database" class="label tags-label">Database</a>
  
    <a href="/tags#distributed-systems" class="label tags-label">Distributed Systems</a>
  
    <a href="/tags#ruby" class="label tags-label">Ruby</a>
  
    <a href="/tags#ruby-on-rails" class="label tags-label">Ruby on Rails</a>
  
</div>

      
      <br>
    </div>
    <div class="sharing-links text-right">
  Share on &nbsp;
  <a href="https://twitter.com/intent/tweet?text=Deep Dive into Database Timeouts in Rails&url=https://engineering.grab.com/deep-dive-into-database-timeouts-in-rails&via=grabengineering&related=grabengineering" class="btn btn-sm btn-share btn-share-twitter" rel="nofollow" target="_new" title="Share on Twitter" onclick="onShareButtonClick(this); return false;"><i class="fa fa-lg fa-twitter"></i>&nbsp; Twitter</a>
  <a href="https://facebook.com/sharer.php?u=https://engineering.grab.com/deep-dive-into-database-timeouts-in-rails" class="btn btn-sm btn-share btn-share-facebook" rel="nofollow" target="_new" title="Share on Facebook" onclick="onShareButtonClick(this); return false;"><i class="fa fa-lg fa-facebook"></i>&nbsp; Facebook</a>
  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://engineering.grab.com/deep-dive-into-database-timeouts-in-rails&title=Deep Dive into Database Timeouts in Rails
&summary=Disaster strikes when you do not configure timeout values properly. In this post, we dive into the details of how timeouts work with Ruby on Rails and Databases.&source=Grab Tech" class="btn btn-sm btn-share btn-share-linkedin" rel="nofollow" target="_new" title="Share on LinkedIn" onclick="onShareButtonClick(this); return false;"><i class="fa fa-lg fa-linkedin"></i>&nbsp; LinkedIn</a>
</div>
<script>
  function onShareButtonClick(button) {
    var width = 600;
    var height = 600;
    var left = (window.screen.width / 2) - (width / 2);
    var top = (window.screen.height / 2) - (height / 2);
    window.open(button.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=' + height + ',width=' + width + ',top=' + top + ',left=' + left);
    return false;
  }
</script>

    <hr class="section-divider">
    <div class="panel panel-default hiring-panel">
      <div class="panel-body">
        <div class="row">
          <div class="col-sm-6">
            <h4 class="hiring-tagline">Want to work with us? Grab is hiring!</h4>
          </div>
          <div class="col-sm-6 hiring-btn-container">
            <a class="btn" href="https://grab.careers" target="_blank">View open positions</a>

          </div>
        </div>
      </div>
    </div>
    <br/>
    
      <div id="disqus_thread"></div>
<script>
  var disqus_config = function () {
    this.page.url = 'https://engineering.grab.com/deep-dive-into-database-timeouts-in-rails';
    this.page.identifier = 'deep-dive-into-database-timeouts-in-rails';
  };
  (function() {
    var d = document, s = d.createElement('script');
    s.src = '//grabengineering.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

    
  </div>
</div>

    </div>
    <footer class="site-footer">
  <div class="wrapper">
    <div class="row">
      <div class="col-sm-6">
        <h2 class="footer-heading">Grab Tech</h2>
        <ul class="social-media-list">
  
    <li>
      <a href="https://github.com/grab" target="_blank" rel="nofollow noreferrer">
        <i class="fa fa-github fa-lg"></i>
      </a>
    </li>
  
  
    <li>
      <a href="https://facebook.com/grabengineering" target="_blank" rel="nofollow noreferrer">
        <i class="fa fa-facebook-square fa-lg"></i>
      </a>
    </li>
  
  
    <li>
      <a href="https://twitter.com/grabengineering" target="_blank" rel="nofollow noreferrer">
        <i class="fa fa-twitter fa-lg"></i>
      </a>
    </li>
  
  
    <li>
      <a href="https://www.linkedin.com/company-beta/5382086" target="_blank" rel="nofollow noreferrer">
        <i class="fa fa-linkedin fa-lg"></i>
      </a>
    </li>
  
  <li>
    <a href="https://engineering.grab.com/feed.xml" target="_blank">
      <i class="fa fa-rss fa-lg"></i>
    </a>
  </li>
</ul>

        <script src="//platform.linkedin.com/in.js" type="text/javascript"> lang: en_US</script>
        <script type="IN/FollowCompany" data-id="5382086" data-counter="right"></script>
      </div>
      <div class="col-sm-6 hiring-section">
        <h2 class="footer-heading">Join Us</h2>
        <p class="text">
          Want to join us in our mission to revolutionize transportation?
        </p>
        <a class="btn" href="https://grab.careers" target="_blank">View open positions</a>

      </div>
    </div>
  </div>
</footer>

    
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-73060858-2', 'auto');
    ga('send', 'pageview');
  </script>


  </body>
</html>
