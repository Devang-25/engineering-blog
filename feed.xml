<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Grab Tech</title>
    <description>Grab's Engineering team solves critical transportation challenges and makes transport freedom a reality for 620 million people in Southeast Asia.
</description>
    <link>https://engineering.grab.com/</link>
    <atom:link href="https://engineering.grab.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 12 Apr 2019 06:36:27 +0000</pubDate>
    <lastBuildDate>Fri, 12 Apr 2019 06:36:27 +0000</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Guiding you Door-to-Door via our Super App!</title>
        <description>&lt;p&gt;Remember landing at an airport or going to your favourite mall and the hassle of finding the pickup spot when you booked a cab? When there are about a million entrances, it can get particularly annoying trying to find the right pickup location!&lt;/p&gt;

&lt;p&gt;Rolling out across South East Asia  is a brand new booking experience from Grab, designed  to make it easier for you to make a booking at large venues like airports, shopping centers, and tourist destinations! With the new booking flow, it will not only be easier to select one of the pre-designated Grab pickup points, you can also find text and image directions to help you navigate your way through the venue for a smoother rendezvous with your driver!&lt;/p&gt;

&lt;h2 id=&quot;inspiration-behind-the-work&quot;&gt;Inspiration behind the work&lt;/h2&gt;

&lt;p&gt;Finding your pick-up point closest to you, let alone predicting it, is incredibly challenging, especially when you are inside huge buildings or in crowded areas. Neeraj Mishra, Product Owner for Places at Grab explains: “We rely on GPS-data to understand user’s location which can be tricky when you are indoors or surrounded by skyscrapers. Since the satellite signal has to go through layers of concrete and steel, it becomes weak which adds to the inaccuracy. Furthermore, ensuring that passengers and drivers have the same pick-up point in mind can be tricky, especially with venues that have multiple entrances. ”  &lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Marina One POI&quot; src=&quot;/img/poi-entrances-venues-door-to-door/image5.jpg&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Grab’s data analysis revealed that “rendezvous distance” (walking distance between the selected pick-up point and where the car is waiting) is more than twice the Grab average when the booking is made from large venues such as airports.&lt;/p&gt;

&lt;p&gt;To solve this issue, Grab launched “Entrances” (the green dots on the map) last year, which lists the various pick-up points available at a particular building, and shows them on the map, allowing users to easily choose the one closest to them, and ensuring their drivers know exactly where they want to be picked up from. Since then, Grab has created more than 120,000 such entrances, and we are delighted to inform you that average of rendezvous distances across all  countries have been steadily going down!&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Decreasing rendezvous distance across region&quot; src=&quot;/img/poi-entrances-venues-door-to-door/image2.png&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;one-problem-remained&quot;&gt;One problem remained&lt;/h2&gt;

&lt;p&gt;But there was still one common pain-point to be solved. Just because a passenger has selected the pick-up point closest to them, doesn’t mean it’s easy for them to find it. This is particularly challenging at very large venues like airports and shopping centres, and especially difficult if the passenger is unfamiliar with the venue, for example - a tourist landing at Jakarta Airport for the very first time. To deliver an even smoother booking and pick-up experience, Grab has rolled out a new feature called Venues - the first in the region - that will give passengers in-app photo and text directions to the pick-up point closest to them.&lt;/p&gt;

&lt;h2 id=&quot;lets-break-it-down-how-does-it-work&quot;&gt;Let’s break it down! How does it work?&lt;/h2&gt;

&lt;p&gt;Whether you are a local or a foreigner on holiday or business trip, fret not if you are not too familiar with the place that you in!&lt;/p&gt;

&lt;p&gt;Let’s imagine that you are now at Singapore Changi Airport: your new booking experience will look something like this!&lt;/p&gt;

&lt;p&gt;Step 1: Fire the Grab app and click on Transport. You will see a welcome screen showing you where you are!&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Welcome to Changi Airport&quot; src=&quot;/img/poi-entrances-venues-door-to-door/image1.jpg&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Step 2: On booking screen, you will see a new pickup menu with a list of available pickup points. Confirm the pickup point you want and make the booking!&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Booking screen at Changi Airport&quot; src=&quot;/img/poi-entrances-venues-door-to-door/image6.jpg&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Step 3: Once you’ve been allocated a driver, tap on the bubble to get directions to your pick-up point!&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Driver allocated at Changi Airport&quot; src=&quot;/img/poi-entrances-venues-door-to-door/image3.jpg&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Step 4: Follow the landmarks and walking instructions and you’ve arrived at your pick-up point!&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Directions to pick-up point at Changi Airport&quot; src=&quot;/img/poi-entrances-venues-door-to-door/image4.jpg&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;curious-about-how-we-got-this-done&quot;&gt;Curious about how we got this done?&lt;/h2&gt;

&lt;h3 id=&quot;data-driven-decisions&quot;&gt;Data-Driven Decisions&lt;/h3&gt;

&lt;p&gt;Based on a thorough data analysis of historical bookings, Grab identified key venues across our markets in Southeast Asia. Then we dispatched our Operations team to the ground, to identify all pick up points and perform detailed on-ground survey of the venue.&lt;/p&gt;

&lt;h3 id=&quot;operations-teams-leg-work&quot;&gt;Operations Team’s Leg Work&lt;/h3&gt;

&lt;p&gt;Nagur Hassan, Operations Manager at Grab, explains the process: “For the venue survey process, we send a team equipped with the tools required to capture the details, like cameras, wifi and bluetooth scanners etc. Once inside the venue, the team identifies strategic landmarks and clear direction signs that are related to drop-off and pick-up points. Team also captures turn-by-turn walking directions to make it easier for Grab users to navigate – For instance, walk towards Starbucks and take a left near H&amp;amp;M store. All the photos and documentations taken on the sites are then brought back to the office for further processing.”&lt;/p&gt;

&lt;h3 id=&quot;quality-assurance&quot;&gt;Quality Assurance&lt;/h3&gt;

&lt;p&gt;Once the data is collected, our in-house team checks the quality of the images and data. We also mask people’s faces and number plates of the vehicles to hide any identity-related information. As of today, we have collected 3400+ images for 1900+ pick up points belonging to 600 key venues! This effort took more than 3000 man-hours in total! And we aim to cover more than 10,000 such venues across the region in the next few months.&lt;/p&gt;

&lt;h2 id=&quot;this-is-only-the-beginning&quot;&gt;This is only the beginning&lt;/h2&gt;

&lt;p&gt;We’re constantly striving to improve the location accuracy of our passengers by using advanced Machine Learning and constant feedback mechanism. We understand GPS may not always be the most accurate determination of your current location, especially in crowded areas and skyscraper districts. This is just the beginning and we’re planning to launch some very innovative features in the coming months! So stay tuned for more!&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Apr 2019 02:08:12 +0000</pubDate>
        <link>https://engineering.grab.com/poi-entrances-venues-door-to-door</link>
        <guid isPermaLink="true">https://engineering.grab.com/poi-entrances-venues-door-to-door</guid>
        
        <category>Grab</category>
        
        <category>Data</category>
        
        <category>Tech</category>
        
        <category>Maps</category>
        
        <category>App</category>
        
        
        <category>Product</category>
        
      </item>
    
      <item>
        <title>Loki, a dynamic mock server for HTTP/TCP testing</title>
        <description>&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;

&lt;p&gt;In a previous article we introduced &lt;a href=&quot;https://engineering.grab.com/mockers&quot;&gt;Mockers - an innovative tool for local box testing at Grab&lt;/a&gt;. Mockers used a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shift_left_testing&quot;&gt;Shift Left testing strategy&lt;/a&gt;, making testing more effective and cheaper for development teams. Mockers’ popularity and success motivated us to create Loki - a one-stop dynamic mock server for local box testing of mobile apps.&lt;/p&gt;

&lt;p&gt;There are some unique challenges in mobile apps testing at Grab. End-to-end testing of an app is difficult due to high dependency on backend services and other apps. Staging environment, which hosts a plethora of backend services, is tough to manage and maintain. Issues such as staging downtime, configuration mismatches, and data corruption can affect staging adding to the testing woes. Moreover, our apps are fairly complex, utilizing multiple transport protocols such as HTTP, HTTPS, TCP for various business flows.&lt;/p&gt;

&lt;p&gt;The business flows are also complex, requiring exhaustive set up such as credit card payments set up, location spoofing, etc resulting in high maintenance costs for automated testing. Loki simulates these flows and developers can easily test use cases that take longer to set up in a real backend staging.&lt;/p&gt;

&lt;p&gt;Loki is our attempt to address challenges in mobile app testing by turning every developer local box into a full fledged pseudo backend environment where all mobile workflows can be tested without any external dependencies. It mocks backend services on developer local boxes, decoupling the mobile apps from real backend services, which provides several advantages such as:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;No need to deploy frequently to staging&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Testing is blocked if the app receives a bad response from staging. In these cases, code changes have to be deployed on staging to fix issues before resuming tests. In contrast, using Loki lets developers continue testing without any immediate need to deploy code changes to staging.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Allows parallel frontend and backend development&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Loki acts as a mock backend service when the real backend is still evolving. It lets the frontend development run in parallel with backend development.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Overcome time limitations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In a one week regression-and-release scenario, testing time is limited. However, the application UI rendering and functionality still needs reasonable testing. Loki lets developers concentrate on testing in the available time instead of fixing dependencies on backend services.&lt;/p&gt;

&lt;h1 id=&quot;loki---grabs-solution-to-simplify-mobile-apps-testing&quot;&gt;Loki - Grab’s solution to simplify mobile apps testing&lt;/h1&gt;

&lt;p&gt;At Grab, we have multiple mobile apps that are dependent on each other. For example, our Passenger and Driver apps are two sides of a coin; the driver gets a job card only when a passenger requests a booking. These apps are developed by different teams, each with its own release cycle. This can make it tricky to confidently and repeatedly test the whole business flow across apps. Apps also depend on multiple backend services to execute a booking or food order and communicate over different protocols.&lt;/p&gt;

&lt;p&gt;Here’s a look at how our mobile apps interact with backend services over different protocols:&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Mobile app interaction with backend services&quot; src=&quot;/img/loki-dynamic-mock-server-http-tcp-testing/image6.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Loki is a dynamic mock server, written in Golang, running in a Docker container on the local box or in CI. It is easy to set up and run through standard Docker commands. In the context of mobile app testing, it plays the role of backend services, so you no longer need to set up an extensive staging environment.&lt;/p&gt;

&lt;p&gt;The Loki architecture looks like this:&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Loki architecture&quot; src=&quot;/img/loki-dynamic-mock-server-http-tcp-testing/image3.png&quot; /&gt;
&lt;/div&gt;

&lt;h1 id=&quot;the-technical-challenges-we-had-to-overcome&quot;&gt;The technical challenges we had to overcome&lt;/h1&gt;

&lt;p&gt;We wanted a comprehensive mocking solution so that teams don’t need to integrate multiple tools to achieve independent testing. It turned out that mocking TCP was most challenging because:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It is a long running client-server connection, and it doesn’t follow an HTTP-like request/response pattern.&lt;/li&gt;
  &lt;li&gt;Messages can be sent to the app without an incoming request as well, hence we had to expose a way via Loki to set a mock expectation which can send messages to the app without any request triggering it.&lt;/li&gt;
  &lt;li&gt;As TCP is a long running connection, we needed a way to delimit incoming requests so we know when we can truncate and deserialize the incoming request into JSON.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We engineered the Loki backend to support both HTTP and TCP protocols on different ports. Yet, the mock expectations are set up using RESTful APIs over HTTP for both protocols. A single point of entry for setting expectations made it more intuitive for our developers.&lt;/p&gt;

&lt;p&gt;An in-memory cron implementation pushes scheduled messages to the app over a TCP connection. This enabled testing of complex use cases such as drivers getting new job cards, driver and passenger chat workflows, etc. The delimiter for TCP protocol is configurable at start up, so each team can decide when to truncate the request.&lt;/p&gt;

&lt;p&gt;To enable Loki on our CI, we had to reduce its memory footprint. Hence, we built Loki with pluggable storages. MySQL is used when running on local and on CI we switch seamlessly to in-memory cache or Redis.&lt;/p&gt;

&lt;p&gt;For testing apps locally, developers must validate complex use cases such as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Payment related flows, which require the response to include the same payment ID as sent in the request. This is a case of simple mapping of request fields in the response JSON.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Flows requiring runtime logic execution. For example, a job card sent to a driver must have a valid timestamp, requiring runtime computation on Loki.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To support these cases and many more, we added JavaScript injection capability to Loki. So, when we set an expectation for an HTTP request/response pair or for TCP events, we can specify JavaScript for computing the dynamic response. This is executed in a sandbox by an in-house JS execution library.&lt;/p&gt;

&lt;p&gt;Grab follows a transactional workflow for bookings. Over the life of a ride, bookings go through different statuses. So, Loki had to address multiple HTTP requests to the same endpoint returning different responses. This feature is required for successfully mocking a whole ride end-to-end.&lt;/p&gt;

&lt;p&gt;Loki uses  an HTTP API &lt;code class=&quot;highlighter-rouge&quot;&gt;“httpTimesAndOrder”&lt;/code&gt; for this feature. For example, using &lt;code class=&quot;highlighter-rouge&quot;&gt;“httpTimesAndOrder”&lt;/code&gt;, you can configure the same status endpoint (&lt;code class=&quot;highlighter-rouge&quot;&gt;/ride/status&lt;/code&gt;) to return different ride statuses such as &lt;code class=&quot;highlighter-rouge&quot;&gt;“PICKING”&lt;/code&gt; for the first five requests, &lt;code class=&quot;highlighter-rouge&quot;&gt;“IN_RIDE”&lt;/code&gt; for the next three requests, and so on.&lt;/p&gt;

&lt;p&gt;Now, let’s look at how to use Loki to mock HTTP requests and TCP events.&lt;/p&gt;

&lt;h1 id=&quot;mocking-http-requests&quot;&gt;Mocking HTTP requests&lt;/h1&gt;

&lt;p&gt;To mock HTTP requests, developers first point their app to send requests to the Loki mock server. Then, they set up expectations for all requests sent to the Loki mock server.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Loki mock server&quot; src=&quot;/img/loki-dynamic-mock-server-http-tcp-testing/image4.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;For example, the Passenger app calls an HTTP dependency &lt;code class=&quot;highlighter-rouge&quot;&gt;GET /closeby/drivers/&lt;/code&gt; to get nearby drivers. To mock it with Loki, you set an expected response on the Loki mock server. When the &lt;code class=&quot;highlighter-rouge&quot;&gt;GET /closeby/drivers/&lt;/code&gt; request is actually made from the Passenger app, Loki returns the set response.&lt;/p&gt;

&lt;p&gt;This snippet shows how to set an expected response for the &lt;code class=&quot;highlighter-rouge&quot;&gt;GET /closeby/drivers/request&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Loki API: POST `/api/v1/expectations`

Request Body :

{
  &quot;uriToMock&quot;: &quot;/closeby/drivers&quot;,
  &quot;method&quot;: &quot;GET&quot;,
  &quot;response&quot;: {
    &quot;drivers&quot;: [
      1001,
      1002,
      1010
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;workflowfor-setting-expectations-and-receiving-responses&quot;&gt;Workflow for setting expectations and receiving responses&lt;/h2&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Workflow for setting expectations and receiving responses&quot; src=&quot;/img/loki-dynamic-mock-server-http-tcp-testing/image5.png&quot; /&gt;
&lt;/div&gt;

&lt;h1 id=&quot;mocking-tcp-events&quot;&gt;Mocking TCP events&lt;/h1&gt;

&lt;p&gt;Developers point their app to Loki over a TCP connection and set up the TCP expectations. Loki then generates scheduled events such as sending push messages (job cards, notifications, etc) to the apps pointing at Loki.&lt;/p&gt;

&lt;p&gt;For example, if the Driver app, after it starts, wants to get a job card, you can set an expectation in Loki to push a job card over the TCP connection to the Driver app after a scheduled time interval.&lt;/p&gt;

&lt;p&gt;This snippet shows how to set the TCP expectation and schedule a push message:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Loki API: POST `/api/v1/tcp/expectations/pushmessage`

Request Body :

{
  &quot;name&quot;: &quot;samplePushMsg&quot;,
  &quot;msgSequence&quot;: [
    {
      &quot;messages&quot;: {
        &quot;body&quot;: {
          &quot;jobCardID&quot;: 1001
        }
      }
    },
    {
      &quot;messages&quot;: {
        &quot;body&quot;: {
          &quot;jobCardID&quot;: 1002
        }
      }
    }
  ],
  &quot;schedule&quot;: &quot;@every 1m&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;workflowfor-scheduling-a-push-message-over-tcp&quot;&gt;Workflow for scheduling a push message over TCP&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;images/image1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Workflow for scheduling a push message over TCP&quot; src=&quot;/img/loki-dynamic-mock-server-http-tcp-testing/image1.png&quot; /&gt;
&lt;/div&gt;

&lt;h1 id=&quot;some-example-use-cases&quot;&gt;Some example use cases&lt;/h1&gt;

&lt;p&gt;Now that you know about Loki, let’s look at some example use cases.&lt;/p&gt;

&lt;h2 id=&quot;generating-a-custom-response-at-runtime&quot;&gt;Generating a custom response at runtime&lt;/h2&gt;

&lt;p&gt;Our first example is customizing a runtime response for both HTTP and TCP requests. This is helpful when developers need dynamic responses to requests. For example, you can add parameters from the request URL or request body to the runtime response.&lt;/p&gt;

&lt;p&gt;It’s simple to implement this with a JavaScript function. Assume you want to embed a message parameter in the request URL to the response. To do this, you first use a POST method to set up the expectation (in JSON format) for the request on Loki:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Loki API: POST `/api/v1/feature/expectations`

Request Body :

{
  &quot;expectations&quot;: [{
    &quot;name&quot;: &quot;Sample call&quot;,
    &quot;desc&quot;: &quot;v1/test/{name}&quot;,
    &quot;tags&quot;: &quot;v1/test/{name}&quot;,
    &quot;resource&quot;: &quot;/v1/test?name=user1&quot;,
    &quot;verb&quot;: &quot;POST&quot;,
    &quot;response&quot;: {
      &quot;body&quot;: &quot;{ \&quot;msg\&quot;: \&quot;Hi \&quot;}&quot;,
      &quot;status&quot;: 200
    },
    &quot;clientOptions&quot;: {
&quot;javascript&quot;: &quot;function main(req, resp) { var url = req.RequestURI; var captured = /name=([^&amp;amp;]+)/.exec(url)[1]; resp.msg =  captured ? resp.msg + captured : resp.msg + 'myDefaultValue'; return resp }&quot;
    },
    &quot;isActive&quot;: 1
  }]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When Loki receives the request, the JavaScript function used in the &lt;code class=&quot;highlighter-rouge&quot;&gt;clientOptionskey&lt;/code&gt;, adds &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; to the response at runtime. For example, this is the request’s fixed response:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;msg&quot;: &quot;Hi &quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But, after using the JavaScript function to add the URL parameter, the dynamic response is:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;msg&quot;: &quot;Hi user1&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Similarly, you can use JavaScript to add other dynamic responses such as modifying the response’s JSON array, adding parameters to push messages, etc.&lt;/p&gt;

&lt;h2 id=&quot;defining-a-response-sequence-for-mocked-api-endpoints&quot;&gt;Defining a response sequence for mocked API endpoints&lt;/h2&gt;

&lt;p&gt;Here’s another interesting example - defining the response sequence for API endpoints.&lt;/p&gt;

&lt;p&gt;A response sequence is useful when you need different responses from the same API endpoint. For example, a status endpoint should return different ride statuses such as ‘allocating’, ‘allocated’, ‘picking’, etc. depending on the stage of a ride.&lt;/p&gt;

&lt;p&gt;To do this, developers set up their HTTP expectations on Loki. Then, they easily define the response sequence for an API endpoint using a Loki POST method.&lt;/p&gt;

&lt;p&gt;In this example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;times&lt;/code&gt; - specifies the number of times the same response is returned.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;after&lt;/code&gt; - specifies one or more expectations that must match before a specified expectation is matched.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here, the expectations are matched in this sequence when a request is made to an endpoint - &lt;code class=&quot;highlighter-rouge&quot;&gt;Allocating&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Allocated&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Pickuser&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Completed&lt;/code&gt;. Further, &lt;code class=&quot;highlighter-rouge&quot;&gt;Completed&lt;/code&gt; is set to two times, so Loki returns this response two times.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Loki API: POST `/api/v1/feature/sequence`

Request Body :
  &quot;httpTimesAndOrder&quot;: [
      {
          &quot;name&quot;: &quot;Allocating&quot;,
          &quot;times&quot;: 1
      },
      {
          &quot;name&quot;: &quot;Allocated&quot;,
          &quot;times&quot;: 1,
          &quot;after&quot;: [&quot;Allocating&quot;]
      },
      {
          &quot;name&quot;: &quot;Pickuser&quot;,
          &quot;times&quot;: 1,
          &quot;after&quot;: [&quot;Allocated&quot;]
      },
      {
          &quot;name&quot;: &quot;Completed&quot;,
          &quot;times&quot;: 2,
          &quot;after&quot;: [&quot;Pickuser&quot;]
      }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;in-conclusion&quot;&gt;In conclusion&lt;/h1&gt;

&lt;p&gt;Since Loki’s inception, we have set up a full range CI with proper end-to-end app UI tests and, to a great extent, decoupled our app releases from the staging backend. This improved delivery cycles, and we did faster bug catching and more exhaustive testing. Moreover, both developers and QAs can easily play with apps to perform exploratory testing as well as manual functional validations. Teams are also using Loki to run automated scripts (Espresso and XCUItests) for validating the mobile app pages.&lt;/p&gt;

&lt;p&gt;Loki’s adoption is growing steadily at Grab. With our frequent release of new mobile app features, Loki helps teams meet our high quality bar and achieve huge productivity gains.&lt;/p&gt;

&lt;p&gt;If you have any feedback or questions on Loki, please leave a comment.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Apr 2019 02:41:42 +0000</pubDate>
        <link>https://engineering.grab.com/loki-dynamic-mock-server-http-tcp-testing</link>
        <guid isPermaLink="true">https://engineering.grab.com/loki-dynamic-mock-server-http-tcp-testing</guid>
        
        <category>Back End</category>
        
        <category>Service</category>
        
        <category>Mobile</category>
        
        <category>Testing</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>How we harnessed the wisdom of crowds to improve restaurant location accuracy</title>
        <description>&lt;p&gt;While studying GPS ping data to understand how long our driver-partners needed to spend at restaurants during a GrabFood delivery, we came across an interesting observation. We realized that there was a significant proportion of restaurants where our driver-partners were waiting for abnormally short durations, often for just seconds.&lt;/p&gt;

&lt;p&gt;Considering that it typically takes a driver a few minutes to enter the restaurant, pick up the order and then leave, we decided to dig further into this phenomenon. What we uncovered was that these super short pit stops were restaurants that were registered at incorrect coordinates within the system due to reasons such as the restaurant had moved to a new location, or human error during onboarding the restaurants. Incorrectly registered locations within our system impact all involved parties - eaters may not see the restaurant because it falls outside their delivery radius or they may see an incorrect ETA, drivers may have trouble finding the restaurant and may end up having to cancel the order, and restaurants who may get fewer orders without really knowing why. &lt;/p&gt;

&lt;p&gt;So we asked ourselves - how can we improve this situation by leveraging the wealth of data that we have? &lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The Solution&lt;/h2&gt;

&lt;p&gt;One of the biggest advantages we have is the huge driver-partner fleet we have on the ground in cities across Southeast Asia. They know the roads and cities like the back of their hand, and they are resourceful. As a result, they are often able to find the restaurants and complete orders even if the location was registered incorrectly. Knowing this, we looked at GPS pings and timestamps from these drivers, and combined this information with when they indicated that they have ordered or collected food from the restaurant. This is then used to infer the “pick-up location” from which the food was collected. &lt;/p&gt;

&lt;p&gt;Inferring this location is not so straightforward though. GPS ping quality can vary significantly across devices and will be affected by whether the device is outdoors or indoors (e.g. if the restaurant is inside a mall). Hence we compute metrics from times and distances between pings, ping frequency and ping quality to filter out orders where the GPS quality is determined to be sub-par. The thresholds for such filtering are determined based on a statistical analysis of orders by regions and times of day. &lt;/p&gt;

&lt;p&gt;One of the outcomes of such an analysis is that we deemed it acceptable to consider a driver “at” a restaurant, if their GPS ping falls within a predetermined radius of the registered location of the restaurant. However, knowing that a driver is at the restaurant does not necessarily tell us “when” he or she  is actually at the restaurant. See the following figure for an example. &lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Map showing driver paths and GPS location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image1.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;As you can see from the area covered by the green circle, there are 3 distinct occurrences or “streaks” when the driver can be determined to be at the restaurant location - once when they are approaching the restaurant from the southwest before taking two right turns, then again when they are actually at the restaurant coming in from the northeast, and again when they leave the restaurant heading southwest before making a U-turn and then heading northeast. In this case, if the driver indicates that they have collected the food during the second streak, chronology is respected - the driver reaches the restaurant, the driver collects the food, the driver leaves the restaurant. However if the driver indicates that they have collected the food during one of the other streaks, that is an invalid pick-up even though it is “at” the restaurant.&lt;/p&gt;

&lt;p&gt;Such potentially invalid pick-ups could result in noisy estimates of restaurant location, as well as hamper us in our parent task of accurately estimating how long drivers need to wait at restaurants. Therefore, we modify the definition of the driver being at the restaurant to only include the time of the longest streak i.e. the time when the driver spent the longest time within the registered location radius. &lt;/p&gt;

&lt;p&gt;Extending this across multiple orders and drivers, we can form a cluster of pick-up locations (both “at” and otherwise) for each restaurant. Each restaurant then gets ranked through a combination of:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order volume&lt;/strong&gt;: Restaurants which receive more orders are likely to have more valid signals for any predictions we make. Increasing the confidence we have in our estimates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fraction of the orders where the pick-up location was not “at” the restaurant&lt;/strong&gt;: This fraction indicates the number of orders with a pick-up location not near the registered restaurant location (with near being defined both spatially and temporally as above). A higher value indicates a higher likelihood of the restaurant not being in the registered location subject to order volume&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Median distance between registered and estimated locations&lt;/strong&gt;: This factor is used to rank restaurants by a notion of “importance”. A restaurant which is just outside the fixed radius from above can be addressed after another restaurant which is a kilometer away. &lt;/p&gt;

&lt;p&gt;This ranked list of restaurants is then passed on to our mapping operations team to verify. The team checks various sources to verify if the restaurant is incorrectly located which is then fed back to the GrabFood system and the locations updated accordingly.&lt;/p&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;We have a system to catch and fix obvious errors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The table below shows a few examples of errors we were able to catch and fix. The image on the left shows the distance between an incorrectly registered address and the actual location of the restaurant.&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Restaurant&lt;/th&gt;
      &lt;th&gt;Path from registered location to estimated location&lt;/th&gt;
      &lt;th&gt;Zoomed in view of estimated location&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Sederhana  Minang&lt;/td&gt;
      &lt;td&gt;&lt;img alt=&quot;Sederhana  Minang path from registered to estimated location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image3.png&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img alt=&quot;Sederhana  Minang zoomed in view of estimated location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image2.png&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Papa Ron's Pizza&lt;/td&gt;
      &lt;td&gt;&lt;img alt=&quot;Papa Ron's Pizza path from registered to estimated location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image6.png&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img alt=&quot;Papa Ron's Pizza zoomed in view of estimated location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image4.png&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Rich-O Donuts &amp;amp; Cafe&lt;/td&gt;
      &lt;td&gt;&lt;img alt=&quot;Rich-O Donuts &amp;amp; Cafe path from registered to estimated location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image9.png&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img alt=&quot;Rich-O Donuts &amp;amp; Cafe zoomed in view of estimated location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image7.png&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Fixing these errors periodically greatly reduced the median error distance (measured as the straight line distance between the estimated location and registered location) in each city as restaurant locations were corrected.&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Bangkok&lt;/th&gt;
      &lt;th&gt;Ho Chi Minh&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img alt=&quot;Median error distance in Bangkok&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image13.png&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img alt=&quot;Median error distance in Ho Chi Minh&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image5.png&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;We helped to reduce cancellations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also tracked the number of GrabFood orders cancelled because the restaurant could not be found by our driver-partners as indicated on the app. Once we started making periodic updates, we saw a 5x decrease in cancellations because of incorrect restaurant locations. &lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Relative cancellation rate due to incorrect location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image8.png&quot; /&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;We discovered some interesting findings!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In some cases, we were actually stumped when trying to correct some of the locations according to what the system estimated. One of the most interesting examples was the restaurant “Waroeng Steak and Shake” in Bekasi. According to our system, the restaurant’s location was further up Jalan Raya Jatiwaringin than we thought it to be. &lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Waroeng Steak and Shake map location&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image10.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Examining this on Google Maps, we noticed that both locations oddly seemed to have a branch of the restaurant. What was going on here? &lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Waroeng Steak and Shake map location on Google Maps&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image11.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;By looking at Google Reviews (credit to my colleague Kenneth Loh for the idea), we realized that  the restaurant seemed to have changed its location, and this is what our system was picking up on. &lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Waroeng Steak and Shake Google Maps reviews&quot; src=&quot;/img/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd/image12.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;In summary, the system was able to respond to a change in location for the restaurant without any active action taken by the restaurant and while other data sources had duplicates. &lt;/p&gt;

&lt;h2 id=&quot;whats-next&quot;&gt;What’s Next?&lt;/h2&gt;

&lt;p&gt;Going forward, we are looking to automate some aspects of this workflow. Currently, the validation part is handled by our mapping operations team and we are looking to feedback their validation and actions taken so that we can finetune various hyperparameters in our system (registered location radii, normalization factors, etc) and/or train more advanced models that are cognizant of different geo and driver characteristics in different markets.&lt;/p&gt;

&lt;p&gt;Additionally while we know that we should expect poor results for some scenarios (e.g. inside malls due to poor GPS quality and often approximate registered locations), we can extract such information (restaurant is inside a mall in this case) through a combination of manual feedback from operations teams and drivers, as well as automated NLP techniques such as name and address parsing and entity recognition. &lt;/p&gt;

&lt;p&gt;In the end, it is always useful to question the predictions that a system makes. By looking at some abnormally small wait times at restaurants, we were able to discover, provide feedback and continually update restaurant locations within the GrabFood ecosystem resulting in an overall better experience for our eaters, driver-partners and merchant-partners.&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Apr 2019 07:43:40 +0000</pubDate>
        <link>https://engineering.grab.com/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd</link>
        <guid isPermaLink="true">https://engineering.grab.com/correcting-restaurant-locations-harnessing-wisdom-of-the-crowd</guid>
        
        <category>Data Science</category>
        
        
        <category>Data Science</category>
        
      </item>
    
      <item>
        <title>Designing resilient systems beyond retries (Part 3): Architecture Patterns and Chaos Engineering</title>
        <description>&lt;p&gt;&lt;em&gt;This post is the third of a three-part series on going beyond retries and circuit breakers to improve system resiliency. This whole series covers techniques and architectures that can be used as part of a strategy to improve resiliency. In this article, we will focus on architecture patterns and chaos engineering to reduce, prevent, and test resiliency.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;reducing-failure-through-architecture-patterns&quot;&gt;Reducing failure through architecture patterns&lt;/h2&gt;

&lt;p&gt;Resiliency is all about preparing for and handling failure. So the most effective way to improve resiliency is undoubtedly to reduce the possible ways in which failure can occur, and several architectural patterns have emerged with this aim in mind. Unfortunately these are easier to apply when designing new systems and less relevant to existing ones, but if resiliency is still an issue and no other techniques are helping, then refactoring the system is a good approach to consider.&lt;/p&gt;

&lt;h3 id=&quot;idempotency&quot;&gt;Idempotency&lt;/h3&gt;

&lt;p&gt;One popular pattern for improving resiliency is the concept of &lt;em&gt;idempotency&lt;/em&gt;. Strictly speaking, an idempotent endpoint is one which always returns the same result given the same parameters, no matter how many times it is called. However, the definition is usually extended to mean it returns the results and has no side-effects, or any side-effects are &lt;em&gt;only executed&lt;/em&gt; once. The main benefit of making endpoints idempotent is that they are always safe to retry, so it complements the retry technique to make it more effective. It also means there is less chance of the system getting into an inconsistent or worse state after experiencing failure.&lt;/p&gt;

&lt;p&gt;If an operation has side-effects but cannot distinguish unique calls with its current parameters, it can be made to be idempotent by adding an &lt;em&gt;idempotency key&lt;/em&gt; parameter. The classic example is money: a ‘transfer money to X’ operation may legitimately occur multiple times with the same parameters, but making the same call twice would be a mistake, so it is not idempotent. A client would not be able to retry a call that timed out, because it does not know whether or not the server processed the request. However, if the client generates and sends a unique ID as an &lt;em&gt;idempotency key&lt;/em&gt; parameter, then it can safely retry. The server can then use this information to determine whether to process the request (if it sees the request for the first time) or return the result of the previous operation.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Using idempotency keys can guarantee idempotency for endpoints with side-effects&quot; src=&quot;/img/beyond-retries-part-3/image1.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Using idempotency keys can guarantee idempotency for endpoints with side-effects&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h3 id=&quot;asynchronous-responses&quot;&gt;Asynchronous responses&lt;/h3&gt;

&lt;p&gt;A second pattern is making use of asynchronous responses. Rather than relying on a successful call to a dependency which may fail, a service may complete its own work and return a successful or partial response to the client. The client would then have to receive the response in an alternate way, either by polling (‘pull’) until the result is ready or the response being ‘pushed’ from the server when it completes.&lt;/p&gt;

&lt;p&gt;From a resiliency perspective, this guarantees that the downstream errors do not affect the endpoint. Furthermore, the risk of the dependency causing latency or consuming resources goes away, and it can be retried in the background until it succeeds. The disadvantage is that this works against the ‘fail fast’ principle, since the call might be retried indefinitely without ever failing. It might not be clear to the client what to do in this case.&lt;/p&gt;

&lt;p&gt;Not all endpoints have to be made asynchronous, and the decision to be synchronous or not could be made by the endpoint dynamically, depending on the service health. Work that can be made asynchronous is known as &lt;em&gt;deferrable work&lt;/em&gt;, and utilizing this information can save resources and allow the more critical endpoints to complete. For example, a fraud system may decide whether or not a newly registered user should be allowed to use the application, but such decisions are often complex and costly. Rather than slow down the registration process for every user and create a poor first impression, the decision can be made asynchronously. When the fraud-decision system is available, it picks up the task and processes it. If the user is then found to be fraudulent, their account can be deactivated at that point.&lt;/p&gt;

&lt;h2 id=&quot;preventing-disaster-through-chaos-engineering&quot;&gt;Preventing disaster through chaos engineering&lt;/h2&gt;

&lt;p&gt;It is famously understood that disaster recovery is worthless unless it’s tested regularly. There are dozens of stories of employees diligently performing backups every day only to find that when they actually needed to restore from it, the backups were empty. The same thing applies to resiliency, albeit with less spectacular consequences.&lt;/p&gt;

&lt;p&gt;The emerging best practice for testing resiliency is &lt;em&gt;chaos engineering&lt;/em&gt;. This practice, made famous by Netflix’s &lt;a href=&quot;https://medium.com/netflix-techblog/the-netflix-simian-army-16e57fbab116&quot;&gt;Chaos Monkey&lt;/a&gt;, is the idea of deliberately causing parts of a system to fail in order to test (and subsequently improve) its resiliency. There are many different kinds of chaos engineering that vary in scope, from simulating an outage in an entire AWS region to injecting latency into a single endpoint. A chaos engineering strategy may include multiple types of failure, to build confidence in the ability of various parts of the system to withstand failure.&lt;/p&gt;

&lt;p&gt;Chaos engineering has evolved since its inception, ironically becoming less ‘chaotic’, despite the name. Shutting off parts of a system without a clear plan is unlikely to provide much value, but is practically guaranteed to frustrate your customers - and upper management! Since it is recommended to experiment on production, minimizing the &lt;em&gt;blast radius&lt;/em&gt; of chaos experiments, at least at the beginning, is crucial to avoid unnecessary impact to the system.&lt;/p&gt;

&lt;h3 id=&quot;chaos-experiment-process&quot;&gt;Chaos experiment process&lt;/h3&gt;

&lt;p&gt;The basic process for conducting a chaos experiment is as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Define how to measure a ‘steady state’, in order to confirm that the system is currently working as expected.&lt;/li&gt;
  &lt;li&gt;Decide on a ‘control group’ (which does not change) and an ‘experiment group’ from the pool of backend servers.&lt;/li&gt;
  &lt;li&gt;Hypothesize that the steady state will not change during the experiment.&lt;/li&gt;
  &lt;li&gt;Introduce a failure in one component or aspect of the system in the control group, such as the network connection to the database.&lt;/li&gt;
  &lt;li&gt;Attempt to disprove the hypothesis by analyzing the difference in metrics between the control and experiment groups.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If the hypothesis is disproved, then the parts of the system which failed are candidates for improvement. After making changes, the experiments are run again, and gradually confidence in the system should improve.&lt;/p&gt;

&lt;p&gt;Chaos experiments should ideally mimic real-world scenarios that could actually happen, such as a server shutting down or a network connection being disconnected. These events do not necessarily have to be directly related to failure - ordinary events such as auto-scaling or a change in server hardware or VM type can be experimented with, as they could still potentially affect the steady state.&lt;/p&gt;

&lt;p&gt;Finally, it is important to automate as much of the chaos experiment process as possible. From setting up the control group to starting the experiment and measuring the results, to automatically disabling the experiment if the impact to production has exceeded the blast radius, the investment in automating them will save valuable engineering time and allow for experiments to eventually be run continuously.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Retries are a useful and important part of building resilient software systems. However, they only solve one part of the resiliency problem, namely recovery. Recovery via retries is only possible under certain conditions and could potentially exacerbate a system failure if other safeguards aren’t also in place. Some of these safeguards and other resiliency patterns have been discussed in this article.&lt;/p&gt;

&lt;p&gt;The excellent Hystrix library combines multiple resiliency techniques, such as circuit-breaking, timeouts and bulkheading, in a single place. But even Hystrix cannot claim to solve all resiliency issues, and it would not be wise to rely on a single library completely. However, just as it can’t be recommended to only use Hystrix, suddenly introducing all of the above patterns isn’t advisable either. There is a point of diminishing returns with adding more; more techniques means more complexity, and more possible things that could go wrong.&lt;/p&gt;

&lt;p&gt;Rather than implement all of the resiliency patterns described above, it is recommended to selectively apply patterns that complement each other and cover existing gaps that have previously been identified. For example, an existing retry strategy can be enhanced by gradually switching to idempotent endpoints, improving the coverage of API calls that can be retried.&lt;/p&gt;

&lt;p&gt;A microservice architecture is a good foundation for building a resilient system, but it requires careful planning and implementation to achieve. By identifying the possible ways in which a system can fail, then evaluating and applying the tried-and-tested patterns to withstand them, a reliable system can become one that is truly resilient.&lt;/p&gt;

&lt;p&gt;I hope you found this series useful. Comments are always welcome.&lt;/p&gt;
</description>
        <pubDate>Wed, 27 Mar 2019 17:17:35 +0000</pubDate>
        <link>https://engineering.grab.com/beyond-retries-part-3</link>
        <guid isPermaLink="true">https://engineering.grab.com/beyond-retries-part-3</guid>
        
        <category>Resiliency</category>
        
        <category>Microservice</category>
        
        <category>Chaos Engineering</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>Designing resilient systems beyond retries (Part 2): Bulkheading, Load Balancing, and Fallbacks</title>
        <description>&lt;p&gt;&lt;em&gt;This post is the second of a three-part series on going beyond retries to improve system resiliency. We’ve previously discussed about rate-limiting as a strategy to improve resiliency. In this article, we will cover these techniques: bulkheading, load balancing, and fallbacks.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;introducing-bulkheading-isolation&quot;&gt;Introducing Bulkheading (Isolation)&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Bulkheading&lt;/em&gt; is a fundamental pattern which underpins many other resiliency techniques, especially where microservices are concerned, so it’s worth introducing first. The term actually comes from an ancient technique in ship building, where a ship’s hull would be partitioned into several watertight compartments. If one of the compartments has a leak, then the water fills just that compartment and is contained, rather than flooding the entire ship. We can apply this principle to software applications and microservices: by isolating failures to individual components, we can prevent a single failure from cascading and bringing down the entire system.&lt;/p&gt;

&lt;p&gt;Bulkheads also help to prevent single points of failure, by reducing the impact of any failures so services can maintain some level of service.&lt;/p&gt;

&lt;h3 id=&quot;level-of-bulkheads&quot;&gt;Level of bulkheads&lt;/h3&gt;

&lt;p&gt;It is important to note that bulkheads can be applied at multiple levels in software architecture. The two highest levels of bulkheads are at the infrastructure level, and the first is &lt;em&gt;hardware isolation&lt;/em&gt;. In a cloud environment, this usually means isolating regions or availability zones. The second is isolating the operating system, which has become a widespread technique with the popularity of virtual machines and now &lt;em&gt;containerization&lt;/em&gt;. Previously, it was common for multiple applications to run on a single (very powerful) dedicated server. Unfortunately, this meant that a rogue application could wreak havoc on the entire system in a number of ways, from filling the disk with logs to consuming memory or other resources.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Isolation can be achieved by applying bulkheading at multiple levels&quot; src=&quot;/img/beyond-retries-part-2/image2.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Isolation can be achieved by applying bulkheading at multiple levels&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;This article focuses on resiliency from the application perspective, so below the system level is process-level isolation. In practical terms, this isolation prevents an application crash from affecting multiple system components. By moving those components into separate processes (or microservices), certain classes of application-level failures are prevented from causing cascading failure.&lt;/p&gt;

&lt;p&gt;At the lowest level, and perhaps the most common form of bulkheading to software engineers, are the concepts of &lt;em&gt;connection pooling&lt;/em&gt; and &lt;em&gt;thread pools&lt;/em&gt;. While these techniques are commonly employed for performance reasons (reusing resources is cheaper than acquiring new ones), they also help to put a finite limit on the number of connections or concurrent threads that an operation is allowed to consume. This ensures that if the load of a particular operation suddenly increases unexpectedly (such as due to external load or downstream latency), the impact is contained to only a partial failure.&lt;/p&gt;

&lt;h3 id=&quot;bulkheading-support-in-the-hystrix-library&quot;&gt;Bulkheading support in the Hystrix library&lt;/h3&gt;

&lt;p&gt;The Hystrix library for Go supports a form of bulkheading through its &lt;code class=&quot;highlighter-rouge&quot;&gt;MaxConcurrentRequests&lt;/code&gt; parameter. This is conveniently tied to the circuit name, meaning that different levels of isolation can be achieved by choosing an appropriate circuit name. A good rule of thumb is to use a different circuit name for each operation or API call. This ensures that if just one particular endpoint of a remote service is failing, the other circuits are still free to be used for the remaining healthy endpoints, achieving failure isolation.&lt;/p&gt;

&lt;h2 id=&quot;load-balancing&quot;&gt;Load balancing&lt;/h2&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Global rate-limiting with a central server&quot; src=&quot;/img/beyond-retries-part-2/image3.jpg&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Global rate-limiting with a central server&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Load balancing is where network traffic from a client may be served by one of many backend servers. You can think of load balancers as traffic cops who distribute traffic on the road to prevent congestion and overload. Assuming the traffic is distributed evenly on the network, this effectively increases the computing power of the backend. Adding capacity like this is a common way to handle an increase in load from the clients, such as when a website becomes more popular.&lt;/p&gt;

&lt;p&gt;Almost always, load balancers provide &lt;em&gt;high availability&lt;/em&gt; for the application. When there is just a single backend server, this server is a ‘single point of failure’, because if it is ever unavailable, there are no servers remaining to serve the clients. However, if there is a pool of backend servers behind a load balancer, the impact is reduced. If there are 4 backend servers and only 1 is unavailable, evenly distributed requests would only fail 25% of the time instead of 100%. This is already an improvement, but modern load balancers are more sophisticated.&lt;/p&gt;

&lt;p&gt;Usually, load balancers will include some form of a health check. This is a mechanism that monitors whether servers in the pool are ‘healthy’, ie. able to serve requests. The implementations for the health check vary, but this can be an active check such as sending ‘pings’, or passive monitoring of responses and removing the failing backend server instances.&lt;/p&gt;

&lt;p&gt;As with rate-limiting, there are many strategies for load balancing to consider.&lt;/p&gt;

&lt;p&gt;There are four main types of load balancer to choose from, each with their own pros and cons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Proxy&lt;/strong&gt;. This is perhaps the most well-known form of load-balancer, and is the method used by Amazon’s Elastic Load Balancer. The proxy sits on the boundary between the backend servers and the public clients, and therefore also doubles as a security layer: the clients do not know about or have direct access to the backend servers. The proxy will handle all the logic for load balancing and health checking. It is a very convenient and popular approach because it requires no special integration with the client or server code. They also typically perform ‘SSL termination’, decrypting incoming HTTPS traffic and using HTTP to communicate with the backend servers.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client-side&lt;/strong&gt;. This is where the client performs all of the load-balancing itself, often using a dedicated library built for the purpose. Compared with the proxy, it is more performant because it avoids an extra network ‘hop.’ However, there is a significant cost in developing and maintaining the code, which is necessarily complex and any bugs have serious consequences.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Lookaside&lt;/strong&gt;. This is a hybrid approach where the majority of the load-balancing logic is handled by a dedicated service, but it does not proxy; the client still makes direct connections to the backend. This reduces the burden of the client-side library but maintains high performance, however the load-balancing service becomes another potential point of failure.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Service mesh with sidecar&lt;/strong&gt;. A service mesh is an all-in-one solution for service communication, with many popular open-source products available. They usually include a sidecar, which is a proxy that sits on the same server as the application to route network traffic. Like the traditional proxy load balancer, this handles many concerns of load-balancing for free. However, there is still an extra network hop, and there can be a significant development cost to integrate with existing systems for logging, reporting and so on, so this must be weighed against building a client-side solution in-house.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Comparison of load-balancer architectures&quot; src=&quot;/img/beyond-retries-part-2/image1.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Comparison of load-balancer architectures&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h3 id=&quot;grabs-load-balancing-implementation&quot;&gt;Grab’s load-balancing implementation&lt;/h3&gt;

&lt;p&gt;At Grab, we have built our own internal client-side solution called CSDP, which uses the distributed key-value store &lt;a href=&quot;https://etcd.io/&quot;&gt;etcd&lt;/a&gt; as its backend store.&lt;/p&gt;

&lt;h2 id=&quot;fallbacks&quot;&gt;Fallbacks&lt;/h2&gt;

&lt;p&gt;There are scenarios when simply retrying a failed API call doesn’t work. If the remote server is completely down or only returning errors, no amount of retries are going to help; the failure is unrecoverable. When recovery isn’t an option, mitigation is an alternative. This is related to the concept of &lt;em&gt;graceful degradation&lt;/em&gt;: sometimes it is preferable to return a less optimal response than fail completely, especially for user-facing applications where user experience is important.&lt;/p&gt;

&lt;p&gt;One such mitigation strategy is &lt;em&gt;fallbacks&lt;/em&gt;. This is a broad topic with many different sub-strategies, but here are a few of the most common:&lt;/p&gt;

&lt;h3 id=&quot;fail-silently&quot;&gt;Fail silently&lt;/h3&gt;

&lt;p&gt;Starting with the easiest to implement, one basic fallback strategy is &lt;em&gt;fail silently&lt;/em&gt;. This means returning an empty or null response when an error is encountered, as if the call had succeeded. If the data being requested is not critical functionality then this can be considered: missing part of a UI is less noticeable than an error page! For example, UI bubbles showing unread notifications are a common feature. But if the service providing the notifications is failing and the bubble shows 0 instead of N notifications, the user’s experience is unlikely to be significantly affected.&lt;/p&gt;

&lt;h3 id=&quot;local-computation&quot;&gt;Local computation&lt;/h3&gt;

&lt;p&gt;A second fallback strategy when a downstream dependency is failing could be to &lt;em&gt;compute the value locally&lt;/em&gt; instead. This could mean either returning a default (static) value, or using a simple formula to compute the response. For example, a marketplace application might have a service to calculate shipping costs. If it is unavailable, then using a default price might be acceptable. Or even $0 - users are unlikely to complain about errors that benefit them, and it’s better than losing business!&lt;/p&gt;

&lt;h3 id=&quot;cached-values&quot;&gt;Cached values&lt;/h3&gt;

&lt;p&gt;Similarly, &lt;em&gt;cached values&lt;/em&gt; are often used as fallbacks. If the service isn’t available to calculate the most up to date value, returning a stale response might be better than returning nothing. If an application is already caching the value with a short expiration to optimize performance, it can be reused as a fallback cache by setting two expiration times: one for normal circumstances, and another when the service providing the response has failed.&lt;/p&gt;

&lt;h3 id=&quot;backup-service&quot;&gt;Backup service&lt;/h3&gt;

&lt;p&gt;Finally, if the response is too complex to compute locally or if major functionality of the application is required to have a fallback, then an entirely new service can act as a fallback; a &lt;em&gt;backup service&lt;/em&gt;. Such a service is a big investment, so to make it worthwhile some trade-offs must be accepted. The backup service should be considerably simpler than the service it is intended to replace; if it is too complex then it will require constant testing and maintenance, not to mention documentation and training to make sure it is well understood within the engineering team. Also, a complex system is more likely to fail when activated. Usually such systems will have very few or no dependencies, and certainly should not depend on any parts of the original system, since they could have failed, rendering the backup system useless.&lt;/p&gt;

&lt;h3 id=&quot;grabs-fallback-implementation&quot;&gt;Grab’s fallback implementation&lt;/h3&gt;

&lt;p&gt;At Grab, we make use of various fallback strategies in our services. For example, our microservice framework &lt;a href=&quot;https://engineering.grab.com/introducing-grab-kit&quot;&gt;Grab-Kit&lt;/a&gt; has built-in support for returning cached values when a downstream service is unresponsive. We’ve even built a backup service to replicate our core functionality, so we can continue to serve customers despite severe technical difficulties!&lt;/p&gt;

&lt;h2 id=&quot;up-next-architecture-patterns-and-chaos-engineering&quot;&gt;Up next, Architecture Patterns and Chaos Engineering…&lt;/h2&gt;

&lt;p&gt;We’ve covered various techniques in designing reliable and resilient systems in the previous articles. I hope you found them useful. Comments are always welcome.&lt;/p&gt;

&lt;p&gt;In our next post, we will look at ways to prevent and reduce failures through architecture patterns and testing.&lt;/p&gt;

&lt;p&gt;Please stay tuned!&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Mar 2019 15:24:33 +0000</pubDate>
        <link>https://engineering.grab.com/beyond-retries-part-2</link>
        <guid isPermaLink="true">https://engineering.grab.com/beyond-retries-part-2</guid>
        
        <category>Resiliency</category>
        
        <category>Microservice</category>
        
        <category>Bulkheading</category>
        
        <category>Load Balancing</category>
        
        <category>Fallbacks</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>Designing resilient systems beyond retries (Part 1): Rate-Limiting</title>
        <description>&lt;p&gt;&lt;em&gt;This post is the first of a three-part series on going beyond retries to improve system resiliency. In this series, we will discuss other techniques and architectures that can be used as part of a strategy to improve resiliency. To start off the series, we will cover rate-limiting.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Software engineers aim for &lt;em&gt;reliability&lt;/em&gt;. Systems that have predictable and consistent behaviour in terms of performance and availability. In the electricity industry, reliability may equate to being able to keep the lights on. But just because a system has remained reliable up until a certain point, does not mean that it will continue to be. This is where &lt;em&gt;resiliency&lt;/em&gt; comes in: the ability to &lt;em&gt;withstand&lt;/em&gt; or &lt;em&gt;recover&lt;/em&gt; from problematic conditions or failure. Going back to our electricity analogy - resiliency is the ability to turn the lights back on quickly when say, a natural disaster hits the power grid.&lt;/p&gt;

&lt;h2 id=&quot;why-we-value-resiliency&quot;&gt;Why we value resiliency&lt;/h2&gt;

&lt;p&gt;Being resilient to many different failures is the best way to ensure a system is reliable and - more importantly - stays that way. At Grab, our architecture features hundreds of microservices, which is constantly stressed in an increasing number of different ways at higher and higher volumes. Failures that would be rare or unusual become more likely as our scale increases. For that reason, we proactively focus on - and require our services to think about - resiliency, even if they have historically been very reliable.&lt;/p&gt;

&lt;p&gt;As software systems evolve and become more complex, the number of potential failure modes that software engineers have to account for grows. Fortunately, so too have the techniques for dealing with them. The &lt;a href=&quot;https://engineering.grab.com/designing-resilient-systems-part-1&quot;&gt;circuit-breaker pattern&lt;/a&gt; and &lt;a href=&quot;https://engineering.grab.com/designing-resilient-systems-part-2&quot;&gt;retries&lt;/a&gt; are two such techniques commonly employed to improve resiliency specifically in the context of distributed systems. In pursuit of reliability, this is a fine start, but it would be wrong to assume that this will keep the service reliable forever. This article will discuss how you can use &lt;em&gt;rate-limiting&lt;/em&gt; as part of a strategy to improve resilience, &lt;em&gt;beyond retries&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;challenges-with-retries-and-circuit-breakers&quot;&gt;Challenges with retries and circuit breakers&lt;/h2&gt;

&lt;p&gt;A common risk when introducing retries in a resiliency strategy is ‘retry storms’. Retries by definition increase the number of requests from the client, especially when the system is experiencing some kind of failure. If the server is not prepared to handle this increase in traffic, and is possibly already struggling to handle the load, it can quickly become overwhelmed. This is counter-productive to introducing retries in the first place!&lt;/p&gt;

&lt;p&gt;When using a circuit-breaker in combination with retries, the application has some form of safety net: too many failures and the circuit will open, preventing the retry storms. However, this can be dangerous to rely on. For one thing, it assumes that all clients have the correct circuit-breaker configurations. Knowing how to configure the circuit-breaker correctly is difficult because it requires knowledge of the downstream service’s configurations too.&lt;/p&gt;

&lt;h2 id=&quot;introducing-rate-limiting&quot;&gt;Introducing rate-limiting&lt;/h2&gt;

&lt;p&gt;In a large organization such as Grab with hundreds of microservices, it becomes increasingly difficult to coordinate and maintain the correct circuit-breaker configurations as the number of services increases.&lt;/p&gt;

&lt;p&gt;Secondly, it is never a good idea for the server to depend on its clients for resiliency. The circuit-breaker could fail or simply be bypassed, and the server would have to deal with all requests the client makes.&lt;/p&gt;

&lt;p&gt;It is therefore desirable to have some form of rate-limiting/throttling as another line of defense. There are many strategies for rate-limiting to consider.&lt;/p&gt;

&lt;h3 id=&quot;types-of-thresholds-for-rate-limiting&quot;&gt;Types of thresholds for rate-limiting&lt;/h3&gt;

&lt;p&gt;The traditional approach to rate-limiting is to implement a server-side check which monitors the rate of incoming requests and if it exceeds a certain threshold, an error will be returned instead of processing the request. There are many algorithms such as ‘&lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;leaky bucket&lt;/a&gt;’, &lt;a href=&quot;https://konghq.com/blog/how-to-design-a-scalable-rate-limiting-algorithm/&quot;&gt;fixed/sliding window&lt;/a&gt; and so on. A key decision is where to set the thresholds: usually by client, endpoint, or a combination of both.&lt;/p&gt;

&lt;p&gt;Rate-limiting by client or user account is the approach taken by many public APIs: Each client is allowed to make a certain number of requests over a period, say 1000 requests per hour, and once that number is exceeded then their requests will be rejected until the time window resets. In this approach, the server must ensure that it has enough capacity (or can scale adequately) to handle the maximum allowed number of requests for each client. If new clients are added frequently, the overhead of maintaining and adjusting the limits may be significant. However, it can be a good way to guarantee a service-level agreement (SLA) with your clients.&lt;/p&gt;

&lt;p&gt;An alternative to per-client thresholds is to use per-endpoint thresholds. This limit is applied across all clients and can be set according to the server’s true capacity using benchmarks. Compared with per-client limits this is easier to configure and more reliable in preventing the server from becoming overloaded. However, one misbehaving client may be able to consume the entire quota, blocking other clients of the service.&lt;/p&gt;

&lt;p&gt;A rate-limiting strategy may use different levels of thresholds, and this is the best approach to get the benefits of both per-client and per-endpoint thresholds. For example, the following rules might be applied (in order):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Per-client, per-endpoint&lt;/strong&gt;: For example, client A accessing the sendEmail endpoint. It is not necessary to configure thresholds at this granularity, but may be useful for critical endpoints.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Per-client&lt;/strong&gt;: In addition to any per-client per-endpoint settings, client A could have a global threshold of 1000 requests/hour to any API.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Per-endpoint&lt;/strong&gt;: This is the server’s catch-all guard to guarantee that none of its endpoints become overloaded. If client limits are properly configured, this limit should never be reached.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Server-wide&lt;/strong&gt;: Finally, a limit on the number of requests a server can handle in total. This is important because even if endpoints can meet their limits individually, they are never completely isolated: the server will have some overhead and limited resources for processing any kind of request, opening and closing network connections etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;local-vs-global-rate-limiting&quot;&gt;Local vs global rate-limiting&lt;/h3&gt;

&lt;p&gt;Another consideration is &lt;em&gt;local&lt;/em&gt; vs &lt;em&gt;global rate-limiting&lt;/em&gt;. As we saw in the previous section, backend servers are usually pooled together for resiliency. A naive rate-limiting solution might be implemented at the individual server instance level. This sounds intuitive because the thresholds can be calculated exactly according to the instance’s computing power, and it scales automatically as the number of instances increases. However, in a microservice architecture, this is rarely correct as the bottlenecks are unlikely to be so closely tied to individual instance hardware.&lt;/p&gt;

&lt;p&gt;More often, the capacity is reached when a downstream resource is exhausted, such as a database, a third-party service or another microservice. If the rate-limiting is only enforced at the instance level, when the service scales, the pressure on these resources will increase and quickly overload them. Local rate-limiting’s effectiveness is limited.&lt;/p&gt;

&lt;p&gt;Global rate-limiting on the other hand monitors thresholds and enforces limits across the entire backend server pool. This is usually achieved through the use of a centralized rate-limiting service to make the decisions about whether or not requests should be allowed to go through. While this is much more desirable, implementing such a service is not without challenges.&lt;/p&gt;

&lt;h2 id=&quot;considerations-when-implementing-rate-limiting&quot;&gt;Considerations when implementing rate-limiting&lt;/h2&gt;

&lt;p&gt;Care must be taken to ensure the rate-limiting service does not become a &lt;em&gt;single point of failure&lt;/em&gt;. The system should still function when the rate-limiter itself is experiencing problems (perhaps by falling back to a local limiter). Since the rate-limiter must be in the request path, it should not add significant latency because any latency would be multiplied across every endpoint being monitored. Grab’s own &lt;a href=&quot;https://engineering.grab.com/quotas-service&quot;&gt;Quotas service&lt;/a&gt; is an example of a global rate-limiter which addresses these concerns.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Global rate-limiting with a central server&quot; src=&quot;/img/beyond-retries-part-1/image1.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Global rate-limiting with a central server. The servers send information about the request volumes, and the rate-limiting service responds with the rate-limiting decisions. This is done asynchronously to avoid introducing a point of failure.&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Generally, it is more important to implement rate-limiting at the server side. This is because, once again, assuming that clients have correct implementation and configurations is risky. However, there is a case to be made for rate-limiting on the client as well, especially if the clients can be trusted or share a common SDK.&lt;/p&gt;

&lt;p&gt;With server-side limiting, the server still has to accept the initial connection, process the rate-limiting logic and return an appropriate error response. With sufficient load, this overhead can be enough to render the system unresponsive; an unintentional denial-of-service (DoS) effect.&lt;/p&gt;

&lt;p&gt;Client-side limiting can be implemented by using a central service as described above or, more commonly, utilizing response headers from the server. In this approach, the server response may include information about the client’s remaining quota and/or a timestamp at which the quota is reset. If the client implements logic for these headers, it can avoid sending requests at all if it knows they will be rate-limited. The disadvantage of this is that the client-side logic becomes more complex and another possible source of bugs, so this cost has to be considered against the simpler server-only method.&lt;/p&gt;

&lt;h2 id=&quot;up-next-bulkheading-load-balancing-and-fallbacks&quot;&gt;Up next, Bulkheading, Load Balancing, and Fallbacks…&lt;/h2&gt;

&lt;p&gt;So we’ve taken a look at rate-limiting as a strategy for having resilient systems. I hope you found this article useful. Comments are always welcome.&lt;/p&gt;

&lt;p&gt;In our next post, we will look at the other resiliency techniques such as bulkheading (isolation), load balancing, and fallbacks.&lt;/p&gt;

&lt;p&gt;Please stay tuned!&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Mar 2019 14:39:33 +0000</pubDate>
        <link>https://engineering.grab.com/beyond-retries-part-1</link>
        <guid isPermaLink="true">https://engineering.grab.com/beyond-retries-part-1</guid>
        
        <category>Resiliency</category>
        
        <category>Microservice</category>
        
        <category>Rate-limiting</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>Context Deadlines and How to Set Them</title>
        <description>&lt;p&gt;At Grab, our microservice architecture involves a huge amount of network traffic and inevitably, network issues will sometimes occur, causing API calls to fail or take longer than expected. We strive to make such incidents a non-event, by designing with the expectation of such incidents in mind. With the aid of Go’s &lt;a href=&quot;https://blog.golang.org/context&quot;&gt;context package&lt;/a&gt;, we have improved upon basic timeouts by passing timeout information along the request path. However, this introduces extra complexity, and care must be taken to ensure timeouts are configured in a way that is efficient and does not worsen problems. This article explains from the ground up a strategy for configuring timeouts and using context deadlines correctly, drawing from our experience developing microservices in a large scale and often turbulent network environment.&lt;/p&gt;

&lt;h2 id=&quot;timeouts&quot;&gt;Timeouts&lt;/h2&gt;

&lt;p&gt;Timeouts are a fundamental concept in computer networking. Almost every kind of network communication will have some kind of timeout associated with it, often configurable with a parameter. The idea is to place a time limit on some event happening, often a network response; after the limit has passed, the operation is aborted rather than waiting indefinitely. Examples of useful places to put timeouts include connecting to a database, making a HTTP request or on idle connections in a pool.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Figure 1.1: How timeouts prevent long API calls&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image5.jpg&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 1.1: How timeouts prevent long API calls&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Timeouts allow a program to continue where it otherwise might hang, providing a better experience to the end user. Often the default way for programs to handle timeouts is to return an error, but this doesn’t have to be the case: there are several better alternatives for handling timeouts which we’ll cover later.&lt;/p&gt;

&lt;p&gt;While they may sound like a panacea, timeouts must be configured carefully to be effective: too short a timeout will result in increased errors from a resource which could still be working normally, and too long a timeout will risk consuming excess resources and a poor user experience. Furthermore, timeouts have evolved over time with new concepts such as Go’s &lt;a href=&quot;https://golang.org/pkg/context/&quot;&gt;context&lt;/a&gt; package, and the trend towards distributed systems has raised the stakes: timeouts are more important, and can cause more damage if misused!&lt;/p&gt;

&lt;h3 id=&quot;why-timeouts-are-useful&quot;&gt;Why timeouts are useful&lt;/h3&gt;

&lt;p&gt;In the context of microservices, timeouts are useful as a defensive measure against misbehaving or faulty dependencies. It is a guarantee that no matter how badly the dependency is failing, your call will never take longer than the timeout setting (for example 1 second). With so many other things to worry about, that’s a really nice thing to have! So there’s an instant benefit to your service’s resiliency, even if you do nothing more than set the timeout.&lt;/p&gt;

&lt;p&gt;However, a service can choose what to do when it encounters a timeout, which can make them even more useful. Generally there are three options:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Return an error&lt;/strong&gt;. This is the simplest, but unless you know there is error handling upstream, this can actually deliver the worst user experience.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Return a fallback value&lt;/strong&gt;. We can return a default value, a cached value, or fall back to a simpler computed value. Depending on the circumstances, this can offer a better user experience.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Retry&lt;/strong&gt;. In the best case, a retry will succeed and deliver the intended response to the caller, albeit with the added timeout delay. However, there are other complexities to consider for retries to be effective. For a full discussion on this topic, see &lt;a href=&quot;https://engineering.grab.com/designing-resilient-systems-part-1&quot;&gt;Circuit Breaker vs Retries Part 1&lt;/a&gt;and &lt;a href=&quot;https://engineering.grab.com/designing-resilient-systems-part-2&quot;&gt;Circuit Breaker vs Retries Part 2&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At Grab, our services tend towards using retries wherever possible, to make minor errors as transparent as possible.&lt;/p&gt;

&lt;p&gt;The main advantage of timeouts is that they give your service &lt;em&gt;time to do something else&lt;/em&gt;, and this should be kept in mind when considering a good timeout value: not only do you want to allow the remote call time to complete (or not), but you need to allow enough time to handle the potential timeout as well.&lt;/p&gt;

&lt;h3 id=&quot;different-types-of-timeouts&quot;&gt;Different types of timeouts&lt;/h3&gt;

&lt;p&gt;Not all timeouts are the same. There are different types of timeouts with crucial differences in semantics, and you should check the behaviour of the timeout settings in the library or resource you’re using before configuring them for production use.&lt;/p&gt;

&lt;p&gt;In Go, there are three common classes of timeouts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Network timeouts&lt;/strong&gt;: These come from the &lt;a href=&quot;https://golang.org/pkg/net/&quot;&gt;net&lt;/a&gt; package and apply to the underlying network connection. These are the best to use when available, because you can be sure that the network call has been cancelled when the call returns to your function.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Context timeouts&lt;/strong&gt;: Context is discussed &lt;a href=&quot;#contexttimeout&quot;&gt;later in this article&lt;/a&gt;, but for now just note that these timeouts are propagated to the server. Since the server is aware of the timeout, it can avoid wasted effort by abandoning computation after the timeout is reached.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Asynchronous timeouts&lt;/strong&gt;: These occur when a goroutine is executed and abandoned after some time. This does &lt;strong&gt;not&lt;/strong&gt; automatically cancel the goroutine (you can’t really cancel goroutines without extra handling), so it risks leaking the goroutine and other resources. This approach should be avoided in production unless combined with some other measures to provide cancellation or avoid leaking resources.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dangers-of-poor-timeout-configuration-for-microservice-calls&quot;&gt;Dangers of poor timeout configuration for microservice calls&lt;/h3&gt;

&lt;p&gt;The benefits of using timeouts are enticing, but there’s no free lunch: relying on timeouts too heavily can lead to disastrous &lt;em&gt;cascading failure&lt;/em&gt; scenarios. Worse, the effects of a poor timeout configuration often don’t become evident until it’s too late: it’s peak hour, traffic just reached an all-time high and… all your services froze up at the same time. Not good.&lt;/p&gt;

&lt;p&gt;To demonstrate this effect, imagine a simple 3-service architecture where each service naively uses a default timeout of 1 second:&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Figure 1.2: Example of how incorrect timeout configuration causes cascading failure&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image3.jpg&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 1.2: Example of how incorrect timeout configuration causes cascading failure&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Service A’s timeout does not account for the fact that Service B calls C. If B itself is experiencing problems and takes 800ms to complete its work, then C effectively only has 200ms to complete before service A gives up. But since B’s timeout to C is also 1s, that means that C could be wasting up to 800ms of computational effort that ‘leaks’ - it has no chance of being used. Both B and C are blissfully unaware at first that anything is wrong - they happily return successful responses that A never receives!&lt;/p&gt;

&lt;p&gt;This resource leak can soon be catastrophic, though: since the calls from B to A are timing out, A (or A’s clients) are likely to retry, causing the load on B to increase. This in turn causes the load on C to increase, and eventually all services will stop responding.&lt;/p&gt;

&lt;p&gt;The same thing happens if B is healthy but C is experiencing problems: B’s calls to C will build up and cause B to become overloaded and fail too. This is a common cause of cascading failure.&lt;/p&gt;

&lt;h3 id=&quot;how-to-set-a-good-timeout&quot;&gt;How to set a good timeout&lt;/h3&gt;

&lt;p&gt;Given the importance of correctly configuring timeout values, the question remains as to how to decide upon a ‘correct’ timeout value. If the timeout is for an API call to another service, a good place to start would be that service’s service-level agreements (SLAs). Often SLAs are based on latency &lt;em&gt;percentiles&lt;/em&gt;, which is a value below which a given percentage of latencies fall. For example, a system might have a 99th percentile (also known as &lt;em&gt;P99&lt;/em&gt;) latency of 300ms; this would mean that 99% of latencies are below 300ms. A high-order percentile such as P99 or even P99.9 can be used as a ballpark &lt;em&gt;worst-case&lt;/em&gt; value.&lt;/p&gt;

&lt;p&gt;Let’s say a service (B)’s endpoint has a 99th percentile latency of 600ms. Setting the timeout for this call at 600ms would guarantee that no calls take longer than 600ms, while returning errors for the rest and accepting an error rate of at most 1% (assuming the service is keeping to their SLA). This is an example of how the timeout can be combined with information about latencies to give predictable behaviour.&lt;/p&gt;

&lt;p&gt;This idea can be taken further by considering retries too. If the median latency for this service is 50ms, then you could introduce a retry of 50ms for an overall timeout of 50ms + 600ms = 650ms:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Service B&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Service B P99 latency SLA = 600ms&lt;/p&gt;

&lt;p&gt;Service B median latency = 50ms&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Service A&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Request timeout = 600ms&lt;/p&gt;

&lt;p&gt;Number of retries = 1&lt;/p&gt;

&lt;p&gt;Retry request timeout = 50ms&lt;/p&gt;

&lt;p&gt;Overall timeout = 50ms+600ms = 650ms&lt;/p&gt;

&lt;p&gt;Chance of timeout after retry = 1% * 50% = 0.5%&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 1.3: Example timeout configuration settings based on latency data&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;This would still cut off the top 1% of latencies, while optimistically making another attempt for the median latency. This way, even for the 1% of calls that encounter a timeout, our service would still expect to return a successful response within 650ms more than half the time, for an overall success rate of 99.5%.&lt;/p&gt;

&lt;h2 id=&quot;context-propagation&quot;&gt;Context propagation&lt;/h2&gt;

&lt;p&gt;Go officially introduced the concept of &lt;a href=&quot;https://golang.org/doc/go1.7%23context&quot;&gt;context in Go 1.7&lt;/a&gt;, as a way of passing request-scoped information across server boundaries. This includes deadlines, cancellation signals and arbitrary values. Let’s ignore the last part for now and focus on deadlines and cancellations. Often, when setting a regular timeout on a remote call, the server side is unaware of the timeout. Even if the server is notified indirectly when the client closes the connection, it’s still not necessarily clear whether the client timed out or encountered another issue. This can lead to wasted resources, because without knowing the client timed out, the server often carries on regardless. Context aims to solve this problem by propagating the timeout and context information across API boundaries.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Figure 1.4: Context propagation cancels work on B and C&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image1.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 1.4: Context propagation cancels work on B and C&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Server A sets a context timeout of 1 second. Since this information spans the entire request and gets propagated to C, C is always aware of the remaining time it has to do useful work - work that won’t get discarded. The remaining time can be defined as (1 - b), where b is the amount of time that server B spent processing before calling C. When the deadline is exceeded, the context is immediately cancelled, along with any child contexts that were created from the parent.&lt;/p&gt;

&lt;p&gt;The context timeout can be a relative time (eg. 3 seconds from now) or an absolute time (eg. 7pm). In practice they are equivalent, and the absolute deadline can be queried from a timeout created with a relative time and vice-versa.&lt;/p&gt;

&lt;p&gt;Another useful feature of contexts is cancellation. The client has the ability to cancel the request for any reason, which will immediately signal the server to stop working. When a context is cancelled manually, this is very similar to a context being cancelled when it exceeds the deadline. The main difference is the error message will be &lt;em&gt;‘context cancelled’&lt;/em&gt; instead of &lt;em&gt;‘context deadline exceeded’&lt;/em&gt;. This is a common cause of confusion, but &lt;em&gt;context cancelled&lt;/em&gt; is &lt;strong&gt;always&lt;/strong&gt; caused by an upstream client, while &lt;em&gt;deadline exceeded&lt;/em&gt; could be a deadline set upstream or locally.&lt;/p&gt;

&lt;p&gt;The server must still listen for the ‘context done’ signal and implement cancellation logic, but at least it has the option of doing so, unlike with ordinary timeouts. The most common reason for cancelling a request is because the client encountered an error and no longer needs the response that the server is processing. However, this technique can also be used in &lt;em&gt;request hedging&lt;/em&gt;, where concurrent duplicate requests are sent to the server to decrease the impact of an individual call experiencing latency. When the first response returns, the other requests are cancelled because they are no longer needed.&lt;/p&gt;

&lt;p&gt;Context can be seen as ‘distributed timeouts’ - an improvement to the concept of timeouts by propagating them. But while they achieve the same goal, they introduce other issues that must be considered.&lt;/p&gt;

&lt;h3 id=&quot;context-propagation-and-timeout-configuration&quot;&gt;Context propagation and timeout configuration&lt;/h3&gt;

&lt;p&gt;When propagating timeout information via context, there is no longer a static ‘timeout’ setting per call. This can complicate debugging: even if the client has correctly configured their own timeout as above, a context timeout could mean that either the remote downstream server is slow, or that an upstream client was slow and there was insufficient time remaining in the propagated context!&lt;/p&gt;

&lt;p&gt;Let’s revisit the scenario from earlier, and assume that service A has set a context timeout of 1 second. If B is still taking 800ms, then the call to C will time out after 200ms. This changes things completely: although there is no longer the resource leak (because both B and C will terminate the call once the context timeout is exceeded), B will have an increase in errors whereas previously it would not (at least until it became overloaded). This may be worse than completing the request after A has given up, depending on the circumstances. There is also a dangerous interaction with &lt;em&gt;circuit breakers&lt;/em&gt; which we will discuss in the next section.&lt;/p&gt;

&lt;p&gt;If allowing the request to complete is preferable than cancelling it even in the event of a client timeout, the request should be made with a new context decoupled from the parent (ie. &lt;code class=&quot;highlighter-rouge&quot;&gt;context.Background()&lt;/code&gt;). This will ensure that the timeout is not propagated to the remote service. When doing this, it is still a good idea to set a timeout, to avoid waiting indefinitely for it to complete.&lt;/p&gt;

&lt;h3 id=&quot;context-and-circuit-breakers&quot;&gt;Context and circuit-breakers&lt;/h3&gt;

&lt;p&gt;A circuit-breaker is a software library or function which monitors calls to external resources with the aim of preventing calls which are likely to fail, ‘short-circuiting’ them (hence the name). It is a good practice to use a circuit-breaker for all outgoing calls to dependencies, especially potentially unreliable ones. But when combined with context propagation, that raises an important question: should context timeouts or cancellation cause the circuit to open?&lt;/p&gt;

&lt;p&gt;Let’s consider the options. If ‘yes’, this means the client will avoid wasting calls to the server if it’s repeatedly hitting the context timeout. This might seem desirable at first, but there are drawbacks too.&lt;/p&gt;

&lt;p&gt;Pros:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Consistent behaviour with other server errors&lt;/li&gt;
  &lt;li&gt;Avoids making calls that are unlikely to succeed&lt;/li&gt;
  &lt;li&gt;It is obvious when things are going wrong&lt;/li&gt;
  &lt;li&gt;Client has more time to fall back to other behaviour&lt;/li&gt;
  &lt;li&gt;More lenient on misconfigured timeouts because circuit-breaking ensures that subsequent calls will fail fast, thus avoiding cascading failure&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unpredictable&lt;/li&gt;
  &lt;li&gt;A misconfigured upstream client can cause the circuit to open for all other clients&lt;/li&gt;
  &lt;li&gt;Can be misinterpreted as a server error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is generally better &lt;em&gt;not&lt;/em&gt; to open the circuit when the context deadline set upstream is exceeded. The only timeout allowed to trigger the circuit-breaker should be the request timeout of the specific call for that circuit.&lt;/p&gt;

&lt;p&gt;Pros:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;More predictable&lt;/li&gt;
  &lt;li&gt;Circuit depends mostly on server health, not client&lt;/li&gt;
  &lt;li&gt;Clients are isolated&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;May be confusing for clients who expect the circuit to open&lt;/li&gt;
  &lt;li&gt;Misconfigured timeouts are more likely to waste resources&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that the above only applies to propagated contexts. If the context only spans a single individual call, then it is equivalent to a static request timeout, and such errors &lt;em&gt;should&lt;/em&gt; cause circuits to open.&lt;/p&gt;

&lt;h2 id=&quot;how-to-set-context-deadlines&quot;&gt;&lt;a name=&quot;contexttimeout&quot;&gt;&lt;/a&gt;How to set context deadlines&lt;/h2&gt;

&lt;p&gt;Let’s recap some of the concepts covered in this article so far:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Timeouts&lt;/strong&gt; are a time limit on an event taking place, such as a microservice completing an API call to another service.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Request timeouts&lt;/strong&gt; refer to the timeout of a single individual request. When accounting for retries, an API call may include several request timeouts before completing successfully.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Context timeouts&lt;/strong&gt; are introduced in Go to propagate timeouts across API boundaries.&lt;/li&gt;
  &lt;li&gt;A &lt;strong&gt;context deadline&lt;/strong&gt; is an absolute timestamp at which the context is considered to be ‘done’, and work covered by this context should be cancelled when the deadline is exceeded.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortunately, there is a simple rule for correctly configuring context timeouts:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The upstream timeout must always be longer than the total downstream timeouts including retries.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The upstream timeout should be set at the ‘edge’ server and cascade throughout.&lt;/p&gt;

&lt;p&gt;In our scenario, A is the edge server. Let’s say that B’s timeout to C is 1s, and it may retry at most once, after a delay of 500ms. The appropriate context timeout (CT) set from A can be calculated as follows:&lt;/p&gt;

&lt;p&gt;CT(A) = (timeout to C * number of attempts) + (retry delay * number of retries)&lt;/p&gt;

&lt;p&gt;CT(A) = (1s * 2) + (500ms * 1) = 2,500ms&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Figure 1.5: Formula for calculating context timeouts&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image2.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 1.5: Formula for calculating context timeouts&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Extra time can be allocated for B’s processing time and to allow B to return a fallback response if appropriate.&lt;/p&gt;

&lt;p&gt;Note that if A configures its timeout according to this rule, then many of the above issues disappear. There are no wasted resources, because B and C are given the maximum time to complete their requests successfully. There is no chance for B’s circuit-breaker to open unexpectedly, and cascading failure is mostly avoided: a failure in C will be handled and be returned by B, instead of A timing out as well.&lt;/p&gt;

&lt;p&gt;A possible alternative would be to rely on context cancellation: allow A to set a shorter timeout, which cancels B and C if the timeout is exceeded. This is an acceptable approach to avoiding cascading failure (and cancellation should be implemented in any case), but it is less optimal than configuring timeouts according to the above formula. One reason is that there is no guarantee of the downstream services handling the timeout gracefully; as mentioned previously, the service must explicitly check for &lt;code class=&quot;highlighter-rouge&quot;&gt;ctx.Done()&lt;/code&gt; and this is rarely followed in practice. It is also impractical to place checks at every point in the code, so there could be a considerable delay between the client cancellation and the server abandoning the processing.&lt;/p&gt;

&lt;p&gt;A second reason not to set shorter timeouts is that it could lead to unexpected errors on the downstream services. Even if B and C are healthy, a shorter context timeout could lead to errors if A has timed out. Besides the problem of having to handle the cancelled requests, the errors could create noise in the logs, and more importantly could have been avoided. If the downstream services are healthy and responding within their SLA, there is no point in timing out earlier. An exception might be for the edge server (A) to allow for only 1 attempt or fewer retries than the downstream service actually performs. But this is tricky to configure and weakens the resiliency. If it is desirable to shorten the timeouts to decrease latency, it is better to start adjusting the timeouts of the downstream resources first, starting from the innermost service outwards.&lt;/p&gt;

&lt;h2 id=&quot;a-model-implementation-for-using-context-timeouts-in-calls-between-microservices&quot;&gt;A model implementation for using context timeouts in calls between microservices&lt;/h2&gt;

&lt;p&gt;We’ve touched on several useful concepts for improving resiliency in distributed systems: timeouts, context, circuit-breakers and retries. It is desirable to use all of them together in a good resiliency strategy. However, the actual implementation is far from trivial; finding the right order and configuration to use them effectively can seem like searching for the holy grail, and many teams go through a long process of trial and error, continuously improving their implementation. Let’s try to formally put together an ideal implementation, step by step.&lt;/p&gt;

&lt;p&gt;Note that the code below is not a final or production-ready implementation. At Grab we have developed independent circuit-breaker and retry libraries, with many settings that can be configured for fine-tuning. However, it should serve as a guide for writing resilient client libraries.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1: Context propagation&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Context propagation code&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image7.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;The skeleton function signature includes a context object as the first parameter, which is the &lt;a href=&quot;https://blog.golang.org/context%23TOC_5&quot;&gt;best practice intended by Google&lt;/a&gt;. We check whether the context is already done before proceeding, in which case we ‘fail fast’ without wasting any further effort.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 2: Create child context with request timeout&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Child context with request timeout code&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image8.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Our service has no control over the parent context. Indeed, it could have no deadline at all! Therefore it’s important to create a new context and timeout for our own outgoing request as well, using &lt;strong&gt;WithTimeout&lt;/strong&gt;. It is mandatory to call the returned &lt;strong&gt;cancel&lt;/strong&gt; function to ensure the context is properly cancelled and avoid a goroutine leak.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3: Introduce circuit-breaker logic&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Introduce circuit-breaker logic code&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image6.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Next, we wrap our call to the external service in a circuit-breaker. The actual circuit-breaker implementation has been omitted for brevity, but there are two important points to consider:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It should only consider opening the circuit-breaker when &lt;strong&gt;requestTimeout&lt;/strong&gt; is reached, not on &lt;code class=&quot;highlighter-rouge&quot;&gt;ctx.Done()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The circuit name should ideally be unique for this specific endpoint&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Introduce circuit-breaker logic code - 2&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image9.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Step 4: Introduce retries&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The last step is to add retries to our request in the case of error. This can be implemented as a simple &lt;strong&gt;for&lt;/strong&gt; loop, but there are some key things to include in a complete retry implementation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ctx.Done()&lt;/code&gt; should be checked after each retry attempt to avoid wasting a call if the client has given up.&lt;/li&gt;
  &lt;li&gt;The request context should be cancelled before the next retry to avoid duplicate concurrent calls and goroutine leaks.&lt;/li&gt;
  &lt;li&gt;Not all kinds of requests should be retried.&lt;/li&gt;
  &lt;li&gt;A delay should be added before the next retry, using exponential backoff.&lt;/li&gt;
  &lt;li&gt;See &lt;a href=&quot;https://engineering.grab.com/designing-resilient-systems-part-2&quot;&gt;Circuit Breaker vs Retries Part 2&lt;/a&gt; for a thorough guide to implementing retries.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Step 5: The complete implementation&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Complete implementation&quot; src=&quot;/img/context-deadlines-and-how-to-set-them/image4.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;And here we have arrived at our ‘ideal’ implementation of an external call including context handling and propagation, two levels of timeout (parent and request), circuit-breaking and retries. This should be sufficient for a good level of resiliency, avoiding wasted effort on both the client and server.&lt;/p&gt;

&lt;p&gt;As a future enhancement, we could consider introducing a ‘minimum time per request’, which the retry loop should use to check for remaining time as well as &lt;code class=&quot;highlighter-rouge&quot;&gt;ctx.Done()&lt;/code&gt; (but not instead - we need to account for client cancellation too). Of course metrics, logging and error handling should also be added as necessary.&lt;/p&gt;

&lt;h2 id=&quot;important-takeaways&quot;&gt;Important Takeaways&lt;/h2&gt;

&lt;p&gt;To summarise, here are a few of the best practices for working with context timeouts:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Use SLAs and latency data to set effective timeouts&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Having a default timeout value for everything doesn’t scale well. Use available information on SLAs and historic latency to set timeouts that give predictable results.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Understand the common error messages&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The context canceled (context.Canceled) error occurs when the context is manually cancelled. This automatically cancels any child contexts attached to the parent. It is rare for this error to surface on the same service that triggered the cancellation; if cancel is called, it is usually because another error has been detected (such as a timeout) which would be returned instead. Therefore, context canceled is usually caused by an upstream error: either the client timed out and cancelled the request, or cancelled the request because it was no longer needed, or closed the connection (this typically results in a cancelled context from Go libraries).&lt;/p&gt;

&lt;p&gt;The context deadline exceeded error occurs only when the time limit was reached. This could have been set locally (by the server processing the request) or by an upstream client. Unfortunately, it’s often difficult to distinguish between them, although they should generally be handled in the same way. If a more granular error is required, it is recommended to use child contexts and explicitly check them for &lt;code class=&quot;highlighter-rouge&quot;&gt;ctx.Done()&lt;/code&gt;, as shown in our model implementation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Check for &lt;code class=&quot;highlighter-rouge&quot;&gt;ctx.Done()&lt;/code&gt; before starting any significant work&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Don’t enter an expensive block of code without checking the context; if the client has already given up, the work will be wasted.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Don’t open circuits for context errors&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This leads to unpredictable behaviour, because there could be a number of reasons why the context might have been cancelled. Only context errors due to request timeouts originating from the local service should lead to circuit-breaker errors.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Set context timeouts at the edge service, using a cascading timeout budget&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The upstream timeout must always be longer than the total downstream timeouts. Following this formula will help to avoid wasted effort and cascading failure.&lt;/p&gt;

&lt;h2 id=&quot;in-conclusion&quot;&gt;In Conclusion&lt;/h2&gt;

&lt;p&gt;Go’s context package provides two extremely valuable tools that complement timeouts: deadline propagation and cancellation. This article has shown the benefits of using context timeouts and how to correctly configure them in a multi-server request path. Finally, we have discussed the relationship between context timeouts and circuit-breakers, proposing a model implementation for integrating them together in a common library.&lt;/p&gt;

&lt;p&gt;If you have a Go server, chances are it’s already making heavy use of context. If you’re new to Go or had been confused by how context works, hopefully this article has helped to clarify misunderstandings. Otherwise, perhaps some of the topics covered will be useful in reviewing and improving your current context handling or circuit-breaker implementation.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Mar 2019 02:50:40 +0000</pubDate>
        <link>https://engineering.grab.com/context-deadlines-and-how-to-set-them</link>
        <guid isPermaLink="true">https://engineering.grab.com/context-deadlines-and-how-to-set-them</guid>
        
        <category>Resiliency</category>
        
        <category>Microservice</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>Recipe for building a widget: How we helped to “peak-shift” demand by helping passengers understand travel trends</title>
        <description>&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Credits: Photo by &lt;a href=&quot;https://unsplash.com/photos/IJFnMSGY_bM&quot;&gt;rawpixel&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/&quot;&gt;Unsplash&lt;/a&gt;&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Stuck in traffic in a Grab ride? Pass the time by opening your Grab app and checking out the Feed - just scroll down! You’ll find widgets for games, polls, videos, news and even food recommendations!&lt;/p&gt;

&lt;p&gt;Beyond serving your everyday needs, we want to provide our users with information that is interesting, useful and relevant. That’s why we’re always coming up with new widgets.&lt;/p&gt;

&lt;p&gt;Building each widget takes close collaboration across multiple different teams - from Product Management to Design, Engineering, Behavioral Science, and Data Science and Analytics. Sounds like a lot of people, doesn’t it? But you’ll be surprised to hear that this behind-the-scenes collaboration works rapidly, usually in the span of one month! Which means we’re often moving from ideation phase to product release in just a few weeks.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot; style=&quot;float: left; width: 50%; margin-right: 1em;&quot;&gt;
  &lt;img alt=&quot;Travel Trends Widget&quot; style=&quot;margin:0;&quot; src=&quot;/img/peak-shift-demand-travel-trends/image6.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;This fast-and-furious process is anchored on one word - “customer-centric”. And that’s how it all began with our  “Travel Trends Widget” - a widget that provides passengers with an overview of historical supply and demand trends for their current location and nearby time periods.&lt;/p&gt;

&lt;p&gt;Because we had so much fun developing this widget, we wanted to write a blog post to share with you what we did and how we did it!&lt;/p&gt;

&lt;h2 id=&quot;inspiration-where-it-all-started&quot;&gt;Inspiration: Where it all started&lt;/h2&gt;

&lt;p&gt;Transport demand can be rather lumpy. Owing to organic patterns (e.g. office hours), a lot of passengers tend to request for cars around the same time. In periods like this, the increase in demand could outpace the arrival of driver supply, increasing the waiting time for passengers.&lt;/p&gt;

&lt;p&gt;Our goal at Grab is to make sure people get a ride when they want it and at the price they want, so we got to thinking about how we can ease this friction by leveraging our treasure trove - Big Data! - to help our passengers better plan their trips.&lt;/p&gt;

&lt;p&gt;As we were looking at the data, we noticed that there is a seasonality to demand and supply: at certain times and days, imbalances appear, peak and disappear, and the process repeats itself. Studies say that humans in general, unless shown a compelling reason or benefit for change, are habitual beings subject to inertia. So we set out to achieve exactly that: To create a widget to surface information to our passengers that may help them alter their decisions on when they choose to book a ride, thereby redistributing some of the present peak demands to periods just before and after peak - also known as “peak shifting the demand”!&lt;/p&gt;

&lt;p&gt;While this widget is the first-of-its-kind in the ride-hailing industry, “peak-shifting” was actually coined and introduced long ago!&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;London Transport Museum Trends&quot; src=&quot;/img/peak-shift-demand-travel-trends/image9.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;As you can see from this post from the London Transport Museum (&lt;a href=&quot;https://twitter.com/TfL/status/657592410906742784&quot;&gt;Source: Transport for London&lt;/a&gt;), London tube tried peak-shifting long before anyone else: Original Ad from 1928 displayed on the left, and Ad from 2015 displayed on the right, comparing the trends to 1928.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot; style=&quot;float: left; width: 50%; margin-right: 1em;&quot;&gt;
  &lt;img alt=&quot;Trends from a hotel in Beijing&quot; style=&quot;margin:0;&quot; src=&quot;/img/peak-shift-demand-travel-trends/image10.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;You may also have seen something similar at the last hotel you stayed at. Notice here a poster in an elevator at a Beijing hotel, announcing the best times to eat breakfast in comfort and avoid the crowd. (Photo credits to Prashant, our Product Manager, who saw this on holiday.)&lt;/p&gt;

&lt;h2 id=&quot;how-the-travel-trends-widget-works&quot;&gt;How the Travel Trends Widget works&lt;/h2&gt;

&lt;p&gt;To apply “peak-shifting” and help our users better plan their trips, we decided to dig in and leverage our data. It was way more complex than we had initially thought, as market conditions could be different on different days. This meant that  generic statements like “5PM-8PM are peak hours and prices will be hight” would not hold true. Contrary to general perception, we observed that even during peak hours, there are buckets of time when there is no surge or low surge.&lt;/p&gt;

&lt;p&gt;For instance, plot 1 and plot 2 below shows how a typical Monday and Tuesday surge looks like in a given month respectively. One of the key insights is that the surge trends during peak hour is different on Monday from Tuesday. It reinforces our initial hypothesis that every day is unique.&lt;/p&gt;

&lt;p&gt;So we used machine learning techniques to build a forecasting widget which can help our users and give them the power to plan their trips beforehand. This widget is able to provide the pricing trends for the next 2 hours. So with a bit of flexibility, riders can ride the tide!&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Grab trends&quot; src=&quot;/img/peak-shift-demand-travel-trends/image3.png&quot; /&gt;
&lt;/div&gt;

&lt;h3 id=&quot;so-how-exactly-does-this-widget-work&quot;&gt;So how exactly does this widget work?!&lt;/h3&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Historical trends for Monday&quot; src=&quot;/img/peak-shift-demand-travel-trends/image7.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;It pulls together historically observed imbalances between supply and demand, for the consumer’s current location and nearby time periods. Aggregated data is displayed to consumers in easily interpreted visualisations, so that they can plan to leave at times when there are more supply, and with potentially more savings for fares.&lt;/p&gt;

&lt;h2 id=&quot;how-did-we-build-the-widget-loop-agile-working-process-poc--workstream&quot;&gt;How did we build the widget? Loop, agile working process, POC &amp;amp; workstream&lt;/h2&gt;

&lt;p&gt;Widget-building is an agile, collaborative, and simultaneous process. First, we started the process with analysis from &lt;strong&gt;Product Analytics&lt;/strong&gt; team, pulling out data on traffic trends, surge patterns, and behavioral insights of both passengers and drivers in Singapore.&lt;/p&gt;

&lt;p&gt;When we noticed the existence of seasonality for each day of the week, we came up with more precise analytical and business questions to dig deeper into the data. Upon verification of hypotheses, we decided that we will build a widget.&lt;/p&gt;

&lt;p&gt;Then joined the &lt;strong&gt;Behavioural Science&lt;/strong&gt;, &lt;strong&gt;UX (User Experience) Design&lt;/strong&gt; and the &lt;strong&gt;Product Management&lt;/strong&gt; teams, who started giving shape to the problem we are solving. Our Behavioural Scientists shared their expertise on how information, suggestions and choices should be presented to enable easy assimilation and beneficial action. Daily whiteboarding breakouts, endless back-and forth conversations, and a healthy amount of challenge-and-accept culture ensured that we distilled the idea down to its core. We then presented the relevant information with just the right level of detail, and with the right amount of messaging, to allow users to take the intended action i.e. shift his/her demand outside of peak periods if possible.&lt;/p&gt;

&lt;p&gt;Our amazing regional &lt;strong&gt;Copywriting team&lt;/strong&gt; then swung in to put our intent into words in 7 different languages for our users across South-East Asia. Simultaneously, our UX designers and &lt;strong&gt;Full-stack Engineers&lt;/strong&gt; started exploring the best visual components to communicate data on time trends to users. More on this later, but suffice to say that plenty of ideas were explored and discarded in a collaborative process, which aimed to create something that’s intuitive and engaging while being robust and scalable to work across all types of devices.&lt;/p&gt;

&lt;p&gt;While these designs made their way up to engineering, the &lt;strong&gt;Data Science&lt;/strong&gt; team worked on finding the most rigorous method to deduce the historical trend of surge across all our cities and areas, and time periods within them. There were discussions on how to best store and update this data reliably so that the widget itself can access it with great performance.&lt;/p&gt;

&lt;p&gt;Soon after, we went into the development process, and voila! We had the first iteration of the widget ready on our staging (internal testing) servers in just 2 weeks! This prototype was opened up to the core team for influx of feedback.&lt;/p&gt;

&lt;p&gt;And just two weeks later, the widget made its way to our Singapore and Jakarta Feeds, accessible to the world at large! Feedback from our users started pouring in almost immediately (thanks to the rich feedback functionality that comes with each widget), ranging from great to sometimes not-so-great, and we listened to all of it with a keen ear! And thus began a new cycle of iterations and continuous improvement, more of which we will share in a subsequent post.&lt;/p&gt;

&lt;h2 id=&quot;in-the-trenches-with-the-creators-how-multiple-teams-got-together-to-make-this-come-true&quot;&gt;In the trenches with the creators: How multiple teams got together to make this come true&lt;/h2&gt;

&lt;p&gt;Various disciplines within our cross functional team came together to whip out this widget by quipping their expertise to the end product.&lt;/p&gt;

&lt;h3 id=&quot;using-behavioural-science-to-simplify-choices-and-design-good-outcomes&quot;&gt;Using Behavioural Science to simplify choices and design good outcomes&lt;/h3&gt;

&lt;p&gt;Behavioural Science helped to explore many facets of consumer behaviour in order to plan and design the widget: understanding how consumers think and conceptualizing a widget that can be easily understood and used by the consumers.&lt;/p&gt;

&lt;p&gt;While fares are governed entirely by market conditions, it’s important for us to explain the economics to customers. As a customer-centric company, we aim to make the consumers feel like they own their decisions, which they can take based on full information. And this is the role of Behavioral Scientists at Grab!&lt;/p&gt;

&lt;p&gt;In guiding the customers through the information, Behavioural Science team had the following three objectives in mind while building this Travel Trends widget:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Offer transparency on the fares: By exposing our historic surge levels for a 4 hour period, we wanted to ensure that the passenger is aware of the surge levels and does not treat the fare as a nasty shock.&lt;/li&gt;
  &lt;li&gt;Give information that helps them plan: By showing them surge levels for the future 2 hours, we wanted to help customers who have the flexibility, plan for a better time, hence, giving them the power to decide based on transparent information.&lt;/li&gt;
  &lt;li&gt;Provide helpful tips: Every bar gives users tips on the conditions at that time and the immediate future. For instance, a low surge bar, followed by a high surge bar gives the tip “Psst… Leave now, It might get busy later!”, helping people understand the graph better and nudging them to take an action. If you are interested in saving fares, may we suggest tapping around all the bars to reveal the secret pro-tips?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;designing-interfaces-that-lead-to-consumer-success-by-abstracting-complexity&quot;&gt;Designing interfaces that lead to consumer success by abstracting complexity&lt;/h3&gt;

&lt;p&gt;Design team is the one behind the colors and shapes that make up the widget that you see and interact with! The team took inspiration from Google’s Popular Times.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Source/Credits: Google Live Popular Times&quot; src=&quot;/img/peak-shift-demand-travel-trends/image1.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Source/Credits: Google Live Popular Times&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Right from the offset, our content and product teams were keen to surface additional information and actions with each bar to keep the widget interactive and useful. One of the early challenges was to arrive at the right gesture that invites the user to interact and intuitively navigate the bars on the widget but also does not conflict with other gestures (eg scrolling and scrubbing) that the user was pre-trained to perform on the feed. We found out that &lt;strong&gt;tapping&lt;/strong&gt; was simultaneously an unused and yet intuitive gesturethat we could use for interaction with the bars.&lt;/p&gt;

&lt;p&gt;We then went into rounds of iteration on the visual design of the widget. In this process, multiple stakeholders were involved ranging from Product to Content to Engineering. We had to overcome a number of constraints i.e. the limited canvas of a widget and the context of a user when she is exploring the feed. By re-using existing libraries and components, we managed to keep the development light and ship something fast.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot; style=&quot;float: left; width: 40%; margin-right: 1em;&quot;&gt;
  &lt;img alt=&quot;GrabCar trends near you&quot; style=&quot;margin: 0;&quot; src=&quot;/img/peak-shift-demand-travel-trends/image11.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Dozens of revisions and four iterations later, we landed with a design that we felt equipped the feature for its user-facing goal, and did so in a manner which was aesthetically appealing!&lt;/p&gt;

&lt;p&gt;And finally we managed to deliver on the feature’s goal, by surfacing just the right detail of information in a manner that is intuitive yet effective to peak-shift demand.  &lt;/p&gt;

&lt;h3 id=&quot;bringing-all-of-this-to-fruition-through-high-performance-engineering&quot;&gt;Bringing all of this to fruition through high performance engineering&lt;/h3&gt;

&lt;p&gt;Our Development Engineering team was in charge of developing the widget and making it available to our users in just a few weeks’ time - materialising the work of the other teams.&lt;/p&gt;

&lt;p&gt;One of their challenges was to find the best way to process the vast amount of data (millions of database entries) so it can be visualized simply as bar charts. Grab’s engineers had to achieve this while making sure performance is as resilient as possible.&lt;/p&gt;

&lt;p&gt;There were two options in doing this:&lt;/p&gt;

&lt;p&gt;a) Fetch the data directly from the DB for each API call; or&lt;/p&gt;

&lt;p&gt;b) Store the data in an in-memory data structure on a timely basis, so when a user calls the API will no longer have to hit the DB.&lt;/p&gt;

&lt;p&gt;After considering that this feature will likely expect a lot of traffic thus high QPS, we decided that the former option would be too costly. Ultimately, we chose the latter option since it is more performant and more scalable.&lt;/p&gt;

&lt;p&gt;At the frontend, the challenge was to cater to the intricate request from our designers. We use chart libraries to increase our development speed, and not all of the requirements were readily supported by these libraries.&lt;/p&gt;

&lt;p&gt;For instance, let’s say this library makes visualising charts easy, but not so much for customising them. If designers wanted to have an average line in a dotted form, the library did not support this so easily. Also, the moving arrow pointers as you move between bar chart, changing colors of the bars changes when clicked – all required countless CSS tweaks.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;CSS tweak on trends widget&quot; src=&quot;/img/peak-shift-demand-travel-trends/image8.png&quot; /&gt;
&lt;/div&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;CSS tweak on trends widget&quot; src=&quot;/img/peak-shift-demand-travel-trends/image5.png&quot; /&gt;
&lt;/div&gt;

&lt;h3 id=&quot;closing-the-product-loop-with-user-feedback-and-data-driven-insights&quot;&gt;Closing the product loop with user feedback and data driven insights&lt;/h3&gt;

&lt;p&gt;One of the most crucial parts of launching any product is to ensure that customers are engaging with the widget and finding it useful.&lt;/p&gt;

&lt;p&gt;To understand what customers think about the widget, whether they find it useful and whether it is helping them to plan better,  we delved into the huge mine of clickstream data.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;User feedback on the trends widget&quot; src=&quot;/img/peak-shift-demand-travel-trends/image2.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;We found that 1 in 3 users who make a booking everyday interact with the widget. And of these people, more than 70% users have given positive rating for the widget. This validates our initial hypothesis that if given an option, our customers will love the freedom to plan their trips and inculcate more transparent ecosystem.&lt;/p&gt;

&lt;p&gt;These users also indicate the things they like most about the widget. 61% of users gave positive rating for usefulness, 20% were impressed by the design (Kudos to our fantastic designer Ajmal!!) and 13% for usability.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Tweet about the widget&quot; src=&quot;/img/peak-shift-demand-travel-trends/image4.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;Beyond internal data, our widget made some rounds on social media channels. For Example, here is screenshot of what our users have to say on Twitter.&lt;/p&gt;

&lt;p&gt;We closely track these metrics on user engagement and feedback to ensure that we keep improving and coming up with new iterations which helps us to serve our customers in a better way.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We hope you enjoyed reading about how we went from ideation, through iterations to a finished widget in the hands of the user, all in 1 month! Many hands helped along the way. If you are interested in joining this hyper-proactive problem-solving team, please check out Grab’s career site!&lt;/p&gt;

&lt;p&gt;And if you have feedback for us, we are here to listen! While we cannot be happier to see some positive reaction from the public, we are also thrilled to hear your suggestions and advice. Please leave us a memo using the Widget’s comment function!&lt;/p&gt;

&lt;h2 id=&quot;epilogue&quot;&gt;Epilogue&lt;/h2&gt;

&lt;p&gt;We just released an upgrade to this widget which allows users to set reminders and be notified about availability of good fares in a time period of their choosing. We will keep a watch and come knocking! Go ahead, find the widget on your Grab feed, set a reminder and save on fares on your next ride!&lt;/p&gt;

</description>
        <pubDate>Thu, 07 Mar 2019 11:55:33 +0000</pubDate>
        <link>https://engineering.grab.com/peak-shift-demand-travel-trends</link>
        <guid isPermaLink="true">https://engineering.grab.com/peak-shift-demand-travel-trends</guid>
        
        <category>Analytics</category>
        
        <category>Data</category>
        
        <category>Data Analytics</category>
        
        
        <category>Data Science</category>
        
        <category>Engineering</category>
        
        <category>Product</category>
        
        <category>Design</category>
        
      </item>
    
      <item>
        <title>Structured Logging: The Best Friend You’ll Want When Things Go Wrong</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Everyday millions of people around Southeast Asia count on Grab to get themselves or what they need from point A to B in a safe, comfortable and reliable manner. In fact, just very recently we crossed our 3 billion transport rides milestone, gaining the last billion in just a mere 6 months!&lt;/p&gt;

&lt;p&gt;We take this responsibility very seriously, and as we continue to grow and expand, it’s important for us to maintain a sophisticated backend system that is capable of sustaining the kind of scale needed to support all our customers in Southeast Asia. This backend system is comprised of multiple services that interact with each other in many different ways. As Grab evolves, maintaining them becomes a significantly larger and harder task as developers continuously develop new features.&lt;/p&gt;

&lt;p&gt;To maintain these systems well, it’s important to have better observability; data that helps us better understand what is happening in the system by having good monitoring (metrics), event logs, and tracing for request scope data. Out of these, logs provide the most complete picture of what happened within the system - and is typically the first and most engaged point of contact. With good logs, the backend becomes much easier to understand, maintain, and debug. Without logs or with bad logs - we have a recipe for disaster; making it nearly impossible to understand what’s happening.&lt;/p&gt;

&lt;p&gt;In this article, we focus on a form of logging called structured logging. We discuss what it is, why is it better, and how we built a framework that integrates well with our current Elastic stack-based logging backend, allowing us to do logging better and more efficiently.&lt;/p&gt;

&lt;p&gt;Structured Logging is a part of a larger endeavour which will enable us to reduce the Mean Time To Resolve (MTTR), helping developers to mitigate issues faster when outages happen.&lt;/p&gt;

&lt;h2 id=&quot;what-are-logs&quot;&gt;What are Logs?&lt;/h2&gt;

&lt;p&gt;Logs are lines of texts containing some information about some event that occurred in our system, and they serve a crucial function of helping us understand what’s happening in the backend. Logs are usually placed at points in the code where a significant event has happened (for example, some database operation succeeded or a passenger got assigned to a driver) or at any other place in the code that we are interested in observing.&lt;/p&gt;

&lt;p&gt;The first thing that a developer would normally do when an error is reported is check the logs - sort of like walking through the history of the system and finding out what happened. Therefore, logs can be a developer’s best friend in times of service outages, errors, and failed builds.&lt;/p&gt;

&lt;p&gt;Logs in today’s world have varying formats and features.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Log Format&lt;/strong&gt;: These range from simple key-value based (like syslog) to quite structured and detailed (like JSON). Since logs are mostly meant for developer eyes, how detailed or structured a log is dictates how fast the developer can query the logs, as well as read them. The more structured the data is - the larger the size is per log line, although it’s more queryable and contains richer information.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Levelled Logging (or Log Levels)&lt;/strong&gt;: Logs with different severities can be logged at different levels. The visibility can be limited to a single level, limiting all logs only with a certain severity or above (for example, only logs WARN and above). Usually log levels are static in production environments, and finding DEBUG logs usually requires redeploying.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Log Aggregation Backend&lt;/strong&gt;: Logs can have different log aggregation backends, which means different backends (i.e. Splunk, Kibana, etc.) decide what your logs might look like or what you might be able to do with them. Some might cost a lot more than others.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Causal Ordering&lt;/strong&gt;: Logs might or might not preserve the exact time in which they are written. This is important, as how exact the time is dictates how accurately we can predict the sequence of events via logs.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Log Correlation&lt;/strong&gt;: We serve countless requests from our backend services. Being able to see all the logs relevant to a particular request or a particular event helps us drill down to relevant  information for a specific request (e.g. for a specific passenger trying to book a ride).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Combine this with the plethora of logging libraries available and you easily have a developer who is holding his head in confusion, unable to decide what to use. Also, each library has their own set of advantages and disadvantages, so the discussion might quickly become subjective and polarized - therefore it is crucial that you choose the appropriate library and backend pair for your applications.&lt;/p&gt;

&lt;p&gt;We at Grab use different types of logging libraries. However, as requirements changed  - we also found ourselves re-evaluating our logging strategy.&lt;/p&gt;

&lt;h2 id=&quot;the-state-of-logging-at-grab&quot;&gt;The State of Logging at Grab&lt;/h2&gt;

&lt;p&gt;The number of Golang services at Grab has continuously grown. Most services used syslog-style key-value format logs, recognized as the most common format of logs for server-side applications due to its simplicity and ease for reading and writing. All these logs were made possible by a handful of common libraries, which were directly imported and used by different services.&lt;/p&gt;

&lt;p&gt;We used a cloud-based SaaS vendor as a frontend for these logs, where application-emitted logs were routed to files and sent to our logging vendor, making it possible to view and query them in real time. Things were pretty great and frictionless for a long time.&lt;/p&gt;

&lt;p&gt;However, as time went by, our logging bills started mounting to unprecedented levels and we found ourselves revisiting and re-evaluating how we did logging. A few issues surfaced:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Logging volume reduction efforts were successful to some extent - but were arduous and painful. Part of the reason was that almost all the logs were at a single log level - INFO.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Figure 1: Log Level Usage&quot; src=&quot;/img/structured-logging/image3.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 1: Log Level Usage&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;This issue was not limited to a single service, but pervasive across services. For mitigation, some services added sampling to logs, some removed logs altogether. The latter is only a recipe for disaster, so it was known that we had to &lt;strong&gt;improve levelled logging&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The vendor was expensive for us at the time and also had a few concerns - primarily with limitations around DSL (query language). There were many good open source alternatives available - Elastic stack to name one. Our engineers felt confident that we could probably manage our logging infrastructure and manage the costs better - which led to the proposal and building of Elastic stack logging cluster. Elasticsearch is vastly more powerful and rich than our vendor at the time and our current libraries weren’t enough to fully leverage its capabilities, so we needed a library which can &lt;strong&gt;leverage structure in logs better&lt;/strong&gt; and &lt;strong&gt;easily integrate with Elastic stack&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;There were some minor issues in our logging libraries namely:
    &lt;ul&gt;
      &lt;li&gt;Singleton initialisation pattern that made unit-testing harder&lt;/li&gt;
      &lt;li&gt;Single logger interface that reduced the possibility of extending the core logging functionality as almost all the services imported the logger interface directly&lt;/li&gt;
      &lt;li&gt;No out-of-the-box support for multiple writers&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If we were to write a library, we had to fix these issues - and also &lt;strong&gt;encourage usage of best practices&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Grab’s critical path (number of services traversed by a single booking flow request) has grown in size. On average, a single booking request touches multiple microservices - each of which does something different. At the large scale at which we operate, it’s necessary therefore to easily view logs from all the services for a single request - however this was not something which was done automatically by the library. Hence, we also wanted to &lt;strong&gt;make log correlation easier and better&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Logs are events which happened at some point of time. The order in which these events occurred gives us a complete history of what happened in the system. However, the core logging library which formed the base of the logging across our Golang services didn’t preserve the log generation time (it instead used write time). This led to jumbling of logs which are generated in a span of a few microseconds - which not only makes the lives of our developers harder, but makes it near impossible to get an exact history of the system. This is why we wanted to also &lt;strong&gt;improve and enable causal ordering of logs&lt;/strong&gt; - one of the key steps in understanding what’s happening in the system.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;why-change&quot;&gt;Why Change?&lt;/h2&gt;

&lt;p&gt;As mentioned, we knew there were issues with how we were logging. To best approach the problem and be able to solve it as much as possible without affecting existing infrastructure and services, it was decided to bootstrap a new library from the ground up. This library would solve known issues, as well as contain features which would not have been possible by modifying existing libraries. For a recap, here’s what we wanted to solve:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Improve levelled logging&lt;/li&gt;
  &lt;li&gt;Leverate structure in logs better&lt;/li&gt;
  &lt;li&gt;Easily integrate with Elastic stack&lt;/li&gt;
  &lt;li&gt;Encourage usage of best practices&lt;/li&gt;
  &lt;li&gt;Make log correlation easier and better&lt;/li&gt;
  &lt;li&gt;Improve and enable causal ordering of logs for a better understanding of service distribution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enter Structured Logging. Structured Logging has been quite popular around the world, finding widespread adoption. It was easily integrable with our Elastic stack backend and would also solve most of our pain points.&lt;/p&gt;

&lt;h2 id=&quot;structured-logging&quot;&gt;Structured Logging&lt;/h2&gt;

&lt;p&gt;Keeping our previous problems and requirements in mind, we bootstrapped a library in Golang, which has the following features:&lt;/p&gt;

&lt;h3 id=&quot;dynamic-log-levels&quot;&gt;Dynamic Log Levels&lt;/h3&gt;

&lt;p&gt;This allows us to change our initialized log levels at runtime from a configuration management system - something which was not possible and encouraged before.&lt;/p&gt;

&lt;p&gt;This makes the log levels actually more meaningful now -  developers can now deploy with the usual WARN or INFO log levels, and when things go wrong, just with a configuration change they can update the log level to DEBUG and make their services output more logs when debugging. This also helps us keep our logging costs in check. We made support for integrating this with our configuration management system easy and straightforward.&lt;/p&gt;

&lt;h3 id=&quot;consistent-structure-in-logs&quot;&gt;Consistent Structure in Logs&lt;/h3&gt;

&lt;p&gt;Logs are inherently unstructured unlike database schema, which is rigid, or a freeform text, which has no structure. Our Elastic stack backend is primarily based on indices (sort of like tables) with mapping (sort of like a loose schema). For this, we needed to output logs in JSON with a consistent structure (for example, we cannot output integer and string under the same JSON field because that will cause an indexing failure in Elasticsearch). Also, we were aware that one of our primary goals was keeping our logging costs in check, and since it didn’t make sense to structure and index almost every field - adding only the structure which is useful to us made sense.&lt;/p&gt;

&lt;p&gt;For addressing this, we built a utility that allows us to add structure to our logs deterministically. This is built on top of a schema in which we can add key-value pairs with a specific key name and type, generate code based on that - and use the generated code to make sure that things are consistently formatted and don’t break. We called this schema (a collection of key name and type pairs) the Common Grab Log Schema (CGLS). We only add structure to CGLS which is important - everything included in CGLS gets formatted in the different field and everything else gets formatted in a single field in the generated JSON. This helps keeps our structure consistent and easily usable with Elastic stack.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Figure 2: Overview of Common Grab Log Schema for Golang backend services&quot; src=&quot;/img/structured-logging/image1.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 2: Overview of Common Grab Log Schema for Golang backend services&lt;/small&gt;
&lt;/div&gt;

&lt;h3 id=&quot;plug-and-play-support-with-grab-kit&quot;&gt;Plug and Play support with Grab-Kit&lt;/h3&gt;

&lt;p&gt;We made the initialization and use easy and out-of-the-box with our in-house support for &lt;a href=&quot;https://engineering.grab.com/introducing-grab-kit&quot;&gt;Grab-Kit&lt;/a&gt;, so developers can just use it without making any drastic changes. Also, as part of this integration, we added automatic log correlation based on request IDs present in traces, which ensured that all the logs generated for a particular request already have that trace ID.&lt;/p&gt;

&lt;h3 id=&quot;configurable-log-format&quot;&gt;Configurable Log Format&lt;/h3&gt;

&lt;p&gt;Our primary requirement was building a logger expressive and consistent enough to integrate with the Elastic stack backend well - without going through fancy log parsing in the downstream. Therefore, the library is expressive and configurable enough to allow any log format (we can write different log formats for different future use cases. For example, readable format in development settings and JSON output in production settings), with a default option of JSON output. This ensures that we can produce log output which is compatible with Elastic stack, but still be configurable enough for different use cases.&lt;/p&gt;

&lt;h3 id=&quot;support-for-multiple-writes-with-different-formats&quot;&gt;Support for Multiple Writes with Different Formats&lt;/h3&gt;

&lt;p&gt;As part of extending the library’s functionality, we needed enough configurability to be able to send different logs to different places at different settings. For example, sending FATAL logs to Slack asynchronously in some readable format, while sending all the usual logs to our Elastic stack backend. This library includes support for chaining such “cores” to any arbitrary degree possible - making sure that this logger can be used in such highly specialized cases as well.&lt;/p&gt;

&lt;h3 id=&quot;production-like-logging-environment-in-development&quot;&gt;Production-like Logging Environment in Development&lt;/h3&gt;

&lt;p&gt;Developers have been seeing console logs since the dawn of time, however having structured JSON logs which are only meant for production logs and are more searchable provides more power. To leverage this power in development better and allow developers to directly see their logs in Kibana, we provide a dockerized version of Kibana which can be spun up locally to accept structured logs. This allows developers to directly use the structured logs and see their logs in Kibana - just like production!&lt;/p&gt;

&lt;p&gt;Having this library enabled us to do logging in a much better way. The most noticeable impact was that our simple access logs can now be queried better - with more filters and conditions.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Figure 3: Production-like Logging Environment in Development&quot; src=&quot;/img/structured-logging/image4.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 3: Production-like Logging Environment in Development&lt;/small&gt;
&lt;/div&gt;

&lt;h3 id=&quot;causal-ordering&quot;&gt;Causal Ordering&lt;/h3&gt;

&lt;p&gt;Having an exact history of events makes debugging issues in production systems easier - as one can just look at the history and quickly hypothesize what’s wrong and fix it. To this end, the structured logging library adds the exact write timestamp in nanoseconds in the logger. This combined with the structured JSON-like format makes it possible to sort all the logs by this field - so we can see logs in the exact order as they happened - achieving causal ordering in logs. This is an underplayed but highly powerful feature that makes debugging easier.&lt;/p&gt;

&lt;div class=&quot;post-image-section&quot;&gt;
  &lt;img alt=&quot;Figure 4: Causal ordering of logs with Y'ALL&quot; src=&quot;/img/structured-logging/image2.png&quot; /&gt;
  &lt;small class=&quot;post-image-caption&quot;&gt;Figure 4: Causal ordering of logs with Y'ALL&lt;/small&gt;
&lt;/div&gt;

&lt;h2 id=&quot;but-why-structured-logging&quot;&gt;But Why Structured Logging?&lt;/h2&gt;

&lt;p&gt;Now that you know about the history and the reasons behind our logging strategy, let’s discuss the benefits that you reap from it.&lt;/p&gt;

&lt;p&gt;On the outset, having logs well-defined and structured (like JSON) has multiple benefits, including but not limited to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Better root cause analysis&lt;/strong&gt;: With structured logs, we can ingest and perform more powerful queries which won’t be possible with simple unstructured logs. Developers can do more informative queries on finding the logs which are relevant to the situation. Not only this, log correlation and causal ordering make it possible to gain a better understanding of the distributed logs. Unlike unstructured data, where we are only limited to full-text or a handful of log types, structured logs take the possibility to a whole new level.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;More transparency or better observability&lt;/strong&gt;: With structured logs, you increase the visibility of what is happening with your system - since now you can log information in a better, more expressive way. This enables you to have a more transparent view of what is happening in the system and makes your systems easier to maintain and debug over longer periods of time.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Better consistency&lt;/strong&gt;: With structured logs, you increase the structure present in your logs - and in turn, make your logs more consistent as the systems evolve. This allows us to index our logs in a system like Elastic stack more easily as we can be sure that we are sticking to some structure. Also with the adoption of a common schema, we can be rest assured that we are all using the same structure.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Better standardization&lt;/strong&gt;: Having a single, well-defined, structured way to do logging allows us to standardize logging - which reduces cognitive overhead of figuring out what happened in systems via logs and allows easier adoption. Instead of going through 100 different types of logs, you instead would only have a single format. This is also one of the goals of the library - standardizing the usage of the library across Golang backend services.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We get some additional benefits as well:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dynamic Log Levels&lt;/strong&gt;: This allows us to have meaningful log levels in our code - where we can deploy with baseline warning settings and switch to lower levels (debug logs) only when we need them. This helps keep our logging costs low, as well as reduces the noise that developers usually need to go through when debugging.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Future-proof Consistency in Logs&lt;/strong&gt;: With the adoption of a common schema, we make sure that we stick with the same structure, even if say tomorrow our logging infrastructure changes - making us future-ready. Instead of manually specifying what to log, we can simply expose a function in our loggers.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Production-Like Logging Environment in Development&lt;/strong&gt;: The dockerized Kibana allows developers to enjoy the same benefits as the production Kibana. This also encourages developers to use Elastic stack more and explore its features such as building dashboards based on the log data, having better watchers, and so on.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I hope you have enjoyed this article and found it useful. Comments and corrections are always welcome.&lt;/p&gt;

&lt;p&gt;Happy Logging!&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Mar 2019 13:07:40 +0000</pubDate>
        <link>https://engineering.grab.com/structured-logging</link>
        <guid isPermaLink="true">https://engineering.grab.com/structured-logging</guid>
        
        <category>Logging</category>
        
        
        <category>Engineering</category>
        
      </item>
    
      <item>
        <title>How we simplified our Data Ingestion &amp; Transformation Process</title>
        <description>&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;As Grab grew from a small startup to an organisation serving millions of customers and driver partners, making day-to-day data-driven decisions became paramount. We needed a system to efficiently ingest data from mobile apps and backend systems and then make it available for analytics and engineering teams.&lt;/p&gt;

&lt;p&gt;Thanks to modern data processing frameworks, ingesting data isn’t a big issue. However, at Grab scale it is a non-trivial task. We had to prepare for two key scenarios:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Business growth, including organic growth over time and expected &lt;a href=&quot;https://en.wikipedia.org/wiki/Seasonality&quot;&gt;seasonality&lt;/a&gt; effects.&lt;/li&gt;
  &lt;li&gt;Any unexpected peaks due to unforeseen circumstances. Our systems have to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalability&quot;&gt;horizontally scalable&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We could ingest data in batches, in real time, or a combination of the two. When you ingest data in batches, you can import it at regularly scheduled intervals or when it reaches a certain size. This is very useful when processes run on a schedule, such as reports that run daily at a specific time. Typically, batched data is useful for offline analytics and data science.&lt;/p&gt;

&lt;p&gt;On the other hand, real-time ingestion has significant &lt;a href=&quot;https://www.forbes.com/sites/forbestechcouncil/2017/08/08/the-value-of-real-time-data-analytics/#459fc6d61220&quot;&gt;business value&lt;/a&gt;, such as with &lt;a href=&quot;https://www.reactivemanifesto.org/&quot;&gt;reactive systems&lt;/a&gt;. For example, when a customer provides feedback for a Grab superapp widget, we re-rank widgets based on that customer’s likes or dislikes. Note when information is very time-sensitive, you must continuously monitor its data.&lt;/p&gt;

&lt;p&gt;This blog post describes how Grab built a scalable data ingestion system and how we went from prototyping with Spark Streaming to running a production-grade data processing cluster written in Golang.&lt;/p&gt;

&lt;h1 id=&quot;building-the-system-without-reinventing-the-wheel&quot;&gt;Building the system without reinventing the wheel&lt;/h1&gt;

&lt;p&gt;The data ingestion system:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Collects raw data as app events.&lt;/li&gt;
  &lt;li&gt;Transforms the data into a structured format.&lt;/li&gt;
  &lt;li&gt;Stores the data for analysis and monitoring.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In a &lt;a href=&quot;https://engineering.grab.com/experimentation-platform-data-pipeline&quot;&gt;previous blog post&lt;/a&gt;, we discussed dealing with batched data ETL with Spark. This post focuses on real-time ingestion.&lt;/p&gt;

&lt;p&gt;We separated the data ingestion system into 3 layers: collection, transformation, and storage. This table and diagram highlights the tools used in each layer in our system’s first design.&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;&lt;th&gt;Layer&lt;/th&gt;&lt;th&gt;Tools&lt;/th&gt;&lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Collection&lt;/td&gt;
      &lt;td&gt;Gateway, &lt;a href=&quot;https://kafka.apache.org/&quot;&gt;Kafka&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Transformation&lt;/td&gt;
      &lt;td&gt;Go processing service, &lt;a href=&quot;https://spark.apache.org/streaming/&quot;&gt;Spark Streaming&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Storage&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://engineering.grab.com/big-data-real-time-presto-talariadb&quot;&gt;TalariaDB&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;img/data-ingestion-transformation-product-insights/image3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Our first design might seem complex, but we used battle-tested and common tools such as Apache &lt;a href=&quot;https://kafka.apache.org/uses&quot;&gt;Kafka&lt;/a&gt; and &lt;a href=&quot;https://spark.apache.org/streaming/&quot;&gt;Spark Streaming&lt;/a&gt;. This let us get an end-to-end solution up and running quickly.&lt;/p&gt;

&lt;h3 id=&quot;collection-layer&quot;&gt;Collection layer&lt;/h3&gt;

&lt;p&gt;Our collection layer had two sub-layers:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Our custom built API Gateway received HTTP requests from the mobile app. It simply decoded and authenticated HTTP requests, streaming the data to the Kafka queue.&lt;/li&gt;
  &lt;li&gt;The Kafka queue decoupled the transformation layer (shown in the above figure as the processing service and Spark streaming) from the collection layer (shown above as the Gateway service). We needed to retain raw data in the Kafka queue for &lt;a href=&quot;https://en.wikipedia.org/wiki/Fault_tolerance&quot;&gt;fault tolerance&lt;/a&gt; of the entire system. Imagine an error where a data pipeline pollutes the data with flawed transformation code or just simply crashes. The Kafka queue saves us from data loss by data backfilling.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since it’s robust and battle-tested, we chose Kafka as our queueing solution. It perfectly met our requirements, such as high throughput and low latency. Although Kafka takes some operational effort such as self-hosting and monitoring, Grab has a proficient and dedicated team managing our Kafka cluster.&lt;/p&gt;

&lt;h3 id=&quot;transformation-layer&quot;&gt;Transformation layer&lt;/h3&gt;

&lt;p&gt;There are many options for real-time data processing, including &lt;a href=&quot;https://spark.apache.org/docs/latest/streaming-programming-guide.html&quot;&gt;Spark&lt;/a&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/streaming-programming-guide.html&quot;&gt; Streaming&lt;/a&gt;, &lt;a href=&quot;https://flink.apache.org/&quot;&gt;Flink&lt;/a&gt;, and &lt;a href=&quot;http://storm.apache.org/&quot;&gt;Storm&lt;/a&gt;. Since we use Spark for all our batch processing, we decided to use Spark Streaming.&lt;/p&gt;

&lt;p&gt;We deployed a Golang processing service between Kafka and Spark Streaming. This service converts the data from &lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;Protobuf&lt;/a&gt; to &lt;a href=&quot;https://avro.apache.org/docs/current/&quot;&gt;Avro&lt;/a&gt;. Instead of pointing Spark Streaming directly to Kafka, we used this processing service as an intermediary. This was because our Spark Streaming job was written in Python and Spark doesn’t natively support &lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;protobuf&lt;/a&gt; decoding.  We used Avro format, since Grab historically used it for archiving streaming data. Each raw event was enriched and batched together with other events. Batches were then uploaded to S3.&lt;/p&gt;

&lt;h3 id=&quot;storage-layer&quot;&gt;Storage layer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://engineering.grab.com/big-data-real-time-presto-talariadb&quot;&gt;TalariaDB&lt;/a&gt; is a Grab-built time-series database. It ingests events as columnar ORC files, indexing them by event name and time. We use the same ORC format files for batch processing. TalariaDB also implements the Presto Thrift connector interface, so our users could query certain event types by time range. They did this by connecting a Presto to a TalariaDB hosting distributed cluster.&lt;/p&gt;

&lt;h1 id=&quot;problems&quot;&gt;Problems&lt;/h1&gt;

&lt;p&gt;Building and deploying our data pipeline’s &lt;a href=&quot;https://en.wikipedia.org/wiki/Minimum_viable_product&quot;&gt;MVP&lt;/a&gt; provided great value to our data analysts, engineers, and QA team. For example, our mobile app team could monitor any abnormal change in the real-time metrics, such as the screen load time for the latest released app version. The QA team could perform app side actions (book a ride, make payment, etc.) and check which events were triggered and received by the backend. The latency between the ingestion and the serving layer was only 4 minutes instead of the batch processing system’s 60 minutes. The streaming processing’s data showed good business value.&lt;/p&gt;

&lt;p&gt;This prompted us to develop more features on top of our platform-collected real-time data. Very soon our QA engineers and the product analytics team used more and more of the real-time data processing system. They started &lt;a href=&quot;https://en.wikipedia.org/wiki/Instrumentation_(computer_programming)&quot;&gt;instrumenting&lt;/a&gt; various mobile applications so more data started flowing in. However, as our ingested data increased, so did our problems. These were mostly related to operational complexity and the increased latency.&lt;/p&gt;

&lt;h3 id=&quot;operational-complexity&quot;&gt;Operational complexity&lt;/h3&gt;

&lt;p&gt;Only a few team members could operate Spark Streaming and EMR. With more data and variable rates, our streaming jobs had scaling issues and failed occasionally. This was due to checkpoint issues when the cluster was under heavy load. Increasing the cluster size helped, but adding more nodes also increased the likelihood of losing more cluster nodes. When we lost nodes,our latency went up and added more work for our already busy on-call engineers.&lt;/p&gt;

&lt;h3 id=&quot;supporting-native-protobuf&quot;&gt;Supporting native Protobuf&lt;/h3&gt;

&lt;p&gt;To simplify the architecture, we initially planned to bypass our Golang-written processing service for the real-time data pipeline. Our plan was to let Spark directly talk to the Kafka queue and send the output to S3. This required packaging the decoders for our protobuf messages for Python Spark jobs, which was cumbersome. We thought about rewriting our job in Scala, but we didn’t have enough experience with it.&lt;/p&gt;

&lt;p&gt;Also, we’d soon hit some streaming limits from S3. Our Spark streaming job was consuming objects from S3, but the process was not continuous due to S3’s &lt;a href=&quot;https://docs.aws.amazon.com/AmazonS3/latest/dev/Introduction.html#ConsistencyModel&quot;&gt; eventual consistency&lt;/a&gt;. To avoid long pagination queries in the S3 API, we had to prefix the data with the hour in which it was ingested. This resulted in some data loss after processing by the Spark streaming. The loss happened because the new data would appear in S3 while Spark Streaming had already moved on to the next hour. We tried various tweaks, but it was just a bad design. As our data grew to over one terabyte per hour, our data loss grew with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/data-ingestion-transformation-product-insights/image1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;processing-lag&quot;&gt;Processing lag&lt;/h3&gt;

&lt;p&gt;On average, the time from our system ingesting an event to when it was available on the Presto was 4 to 6 minutes. We call that processing lag, as it happened due to our data processing. It was substantially worse under heavy loads, increasing to 8 to 13 minutes. While that wasn’t bad at this scale (a few TBs of data), it made some use cases impossible, such as monitoring. We needed to do better.&lt;/p&gt;

&lt;h2 id=&quot;simplifying-the-architecture-and-rewriting-in-golang&quot;&gt;Simplifying the architecture and rewriting in Golang&lt;/h2&gt;

&lt;p&gt;After completing the MVP phase development, we noticed the Spark Streaming functionality we actually used was relatively trivial. In the Spark Streaming job, we only:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Partitioned the batch of events by event name.&lt;/li&gt;
  &lt;li&gt;Encoded the data in ORC format.&lt;/li&gt;
  &lt;li&gt;And uploaded to an S3 bucket.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To mitigate the problems mentioned above, we tried re-implementing the features in our existing Golang processing service. Besides consuming the data and publishing to an S3 bucket, the transformation service also needed to deal with event partitioning and ORC encoding.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/data-ingestion-transformation-product-insights/image4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One key problem we addressed was implementing a robust event partitioner with a large write throughput and low read latency. Fortunately, Golang has a nice &lt;a href=&quot;https://golang.org/pkg/sync/#Map&quot;&gt;concurrent map&lt;/a&gt; package. To further reduce the lock contention, we added &lt;a href=&quot;https://www.openmymind.net/Shard-Your-Hash-table-to-reduce-write-locks/&quot;&gt;sharding&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We made the changes, deployed the service to production,and discovered our service was now &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_bound_function&quot;&gt;memory-bound&lt;/a&gt; as we buffered data for 1 minute. We did thorough benchmarking and profiling on heap allocation to improve memory utilization. By iteratively reducing inefficiencies and contributing to a lower CPU consumption, we made our data transformation more efficient.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/data-ingestion-transformation-product-insights/image2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;performance&quot;&gt;Performance&lt;/h3&gt;

&lt;p&gt;After revamping the system, the elapsed time for a single event to travel from the gateway to our dashboard is about 1 minute. We also fixed the data loss issue. Finally, we significantly reduced our on-call workload by removing Spark Streaming.&lt;/p&gt;

&lt;h3 id=&quot;validation&quot;&gt;Validation&lt;/h3&gt;

&lt;p&gt;At this point, we had both our old and new pipelines running in parallel. After drastically improving our performance, we needed to confirm we still got the same end results. This was done by running a query against each of the pipelines and comparing the results. Both systems were registered to the same Presto cluster.&lt;/p&gt;

&lt;p&gt;We ran two SQL “excerpts” between the two pipelines in different order. Both queries returned the same events, validating our new pipeline’s correctness.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select count(1) from ((
 select uuid, time from grab_x.realtime_new
 where event = 'app.metric1' and time between 1541734140 and 1541734200
) except (
 select uuid, time from grab_x.realtime_old
 where event = 'app.metric1' and time between 1541734140 and 1541734200
))

/* output: 0 */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;Scaling a data ingestion system to handle hundreds of thousands of events per second was a non-trivial task. However, by iterating and constantly simplifying our overall architecture, we were able to efficiently ingest the data and drive down its lag to around one minute.&lt;/p&gt;

&lt;p&gt;Spark Streaming was a great tool and gave us time to understand the problem. But, understanding what we actually needed to build and iteratively optimise the entire data pipeline led us to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Replacing Spark Streaming with our new Golang-implemented pipeline.&lt;/li&gt;
  &lt;li&gt;Removing Avro encoding.&lt;/li&gt;
  &lt;li&gt;Removing an intermediary S3 step.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Differences between the old and new pipelines are:&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;Old Pipeline&lt;/th&gt;
    &lt;th&gt;New Pipeline&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Languages&lt;/th&gt;
    &lt;td&gt;Python, Go&lt;/td&gt;
    &lt;td&gt;Go&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Stages&lt;/th&gt;
    &lt;td&gt;4 services&lt;/td&gt;
    &lt;td&gt;3 services&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Conversions&lt;/th&gt;
    &lt;td&gt;Protobuf → Avro → ORC&lt;/td&gt;
    &lt;td&gt;Protobuf → ORC&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Lag&lt;/th&gt;
    &lt;td&gt;4-13 min&lt;/td&gt;
    &lt;td&gt;1 min&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Systems usually become more and more complex over time, leading to tech debt and decreased performance. In our case, starting with more steps in the data pipeline was actually the simple solution, since we could re-use existing tools. But as we reduced processing stages, we’ve also seen fewer failures. By simplifying the problem, we improved performance and decreased operational complexity. At the end of the day, our data pipeline solves exactly our problem and does nothing else, keeping things fast.&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Mar 2019 18:43:40 +0000</pubDate>
        <link>https://engineering.grab.com/data-ingestion-transformation-product-insights</link>
        <guid isPermaLink="true">https://engineering.grab.com/data-ingestion-transformation-product-insights</guid>
        
        <category>Big Data</category>
        
        <category>Data Pipeline</category>
        
        
        <category>Engineering</category>
        
      </item>
    
  </channel>
</rss>
